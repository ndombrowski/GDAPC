[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GDA: Data analysis",
    "section": "",
    "text": "In this course, you’ll explore the “analyze” phase of the data analysis process. You’ll take what you’ve learned to this point and apply it to your analysis to make sense of the data you’ve collected. You’ll learn how to organize and format your data using spreadsheets and SQL to help you look at and think about your data in different ways. You’ll also find out how to perform complex calculations on your data to complete business objectives. You’ll learn how to use formulas, functions, and SQL queries as you conduct your analysis.\nBy the end of this course, you will:\n\nLearn how to organize data for analysis.\nDiscover the processes for formatting and adjusting data.\nGain an understanding of how to aggregate data in spreadsheets and by using SQL.\nUse formulas and functions in spreadsheets for data calculations.\nLearn how to complete calculations using SQL queries."
  },
  {
    "objectID": "code/1_organizing_data.html",
    "href": "code/1_organizing_data.html",
    "title": "2  Organizing the data to begin analysis",
    "section": "",
    "text": "Analysis is the process used to make sense of the data collected. The goal of analysis is to identify trends and relationships within the data so that you can accurately answer the question you’re asking. To do this, you should stick to the 4 phases of analysis:\n\nOrganize data: A data analyst uses data organization to decide which data is relevant to their analysis and which data types and variables are appropriate\nFormat and adjust data\nGet input from others\nTransform data"
  },
  {
    "objectID": "code/1_organizing_data.html#organzing-data",
    "href": "code/1_organizing_data.html#organzing-data",
    "title": "2  Organizing the data to begin analysis",
    "section": "2.2 Organzing data",
    "text": "2.2 Organzing data\nSorting and filtering are two ways you can keep things organized when you format and adjust data to work with it. For example, a filter can help you find errors or outliers so you can fix or flag them before your analysis. Outliers are data points that are very different from similarly collected data and might not be reliable values.\nExamples were run with BigQuery using data/movie_data.csv\n\n2.2.1 Spreadsheets\nIf Sort sheet is applied, all of the data in a spreadsheet is sorted by the conditions of a single column, but the related information across each row stays together.\nSort range doesn’t keep the information across rows together. When you sort a range, you’re selecting a specific collection of cells or the range that you want the sorting limited to. Nothing else on the spreadsheet gets rearranged but the specified cells.\nA formula do use is the sort function, i.e. =SORT(A2:D6, 2, TRUE)\n\nStart with the first cell the data is collected from and separate with a colon until the last cell we want to include\nAfter the comma, to separate the range from what we are sorting by: column B. You should keep in mind that this part of the function doesn’t recognize column letters. So in this case, we use the corresponding number instead, which is 2, since column B is the second column in our range.\nIn this next part you’ll need to decide whether you want the data in this column to be in ascending or descending order. A TRUE statement is in ascending order, and FALSE is descending.\n\nA customized sort order is when you sort data in a spreadsheet using multiple conditions. This means that sorting will be based on the order of the conditions you select. You can do that easily with the “Sort range” and “advanced sorting” option under Data.\nSimilar to the SORT function in Google Sheets, Excel includes custom sort capabilities that are available from the menu. After you select the data range, click the Sort & Filter button to select the criteria for sorting.\n\n\n2.2.2 SQL\nYou can use the ORDER BY clause to sort results returned in a query. By default, the ORDER BY clause sorts data in ascending order.\n\nSELECT * \nFROM `lithe-vault-366813.movie_data.movies`\nORDER BY Release_Date DESC\n\nCombine sorting and filtering. First, we’ll check that the ORDER BY clause is always the last line. That makes sure that all the results of the query you’re running are sorted by that clause. Then, we’ll add a new line for the WHERE clause after FROM and before ORDER BY.\n\nSELECT * \nFROM `lithe-vault-366813.movie_data.movies`\nWHERE Genre = 'Comedy'\nORDER BY Release_Date DESC\n\nWe can also filter for two conditions at once using the AND filter.\n\nSELECT * \nFROM `lithe-vault-366813.movie_data.movies`\nWHERE Genre = 'Comedy' AND Revenue > 3000000\nORDER BY Release_Date DESC"
  },
  {
    "objectID": "code/2_converting_and_formatting.html",
    "href": "code/2_converting_and_formatting.html",
    "title": "3  Converting and formatting data",
    "section": "",
    "text": "On the format toolbar at the top of the sheet, you’ll find a menu that can help you convert these numbers into specific data types.\nFor another case, imagine the temperatures are in Fahrenheit, but for your analysis you need them to be in Celsius. For this we can use the CONVERT function. Make sure after using formulas to convert them to static values to not have weird mess-ups later.\n=CONVERT(B3, \"F\", \"C\")\nWe could also convert the wind speed from miles per hour (mph) to meters per second (m/s) using CONVERT\n=CONVERT(D2, \"mph\", \"m/s\")\n\n\n\nThe CONCAT function in spreadsheets can combine any kinds of data.\n=CONCAT(A2, B2)\nIf you want to put the space in between, you need to use the full CONCATENATE function, which allows you to combine multiple strings.\n=CONCATENATE(A2, \" \",  B2)\n\n\n\nData validation allows you to control what can and can’t be entered in your worksheet.\nUsually, data validation is used to add drop-down lists to cells with predetermined options for users to choose from.\n\nSelect the column we want to add a drop-down menu to\nGo to data –> Data validation\nAdd the criteria, i.e. if we want to add a list of items other users can choose from\n\nWe can also create custom checkboxes\n\nGo into the column we want to create checkboxes in\nGo into the data validation menu: data –> Data validation\nSelect checkbox\nUse custom cell values, i.e. \n\nWe can also use data validation to protect structured data and formulas:\n\nGo to data –> Data validation\nCheck the option to reject invalid inputs, which helps make sure our custom tools will continue to run correctly, even if someone puts the wrong data in by mistake\n\n\n\n\n\nFormat –> Conditional formatting\nSelect cells\nDefine rules\n\n\n\n\nRefer to Conversion Rules in Standard SQL for a full list of functions and associated rules.\n\n\nCAST is an American National Standards Institute (ANSI) function used in lots of programming languages, including BigQuery.\nCAST (expression AS typename)\nWhere expression is the data to be converted and typename is the data type to be returned.\nThe following CAST statement returns a string from a numeric identified by the variable MyCount in the table called MyTable.\nCAST (MyCount AS STRING) FROM MyTable\nThe following CAST statement returns an integer from a string identified by the variable MyVarcharCol in the table called MyTable. (An integer is any whole number.)\nSELECT CAST (MyVarcharCol AS INT) FROM MyTable"
  },
  {
    "objectID": "code/2_converting_and_formatting.html#combining-multiple-datasets",
    "href": "code/2_converting_and_formatting.html#combining-multiple-datasets",
    "title": "3  Converting and formatting data",
    "section": "3.2 Combining multiple datasets",
    "text": "3.2 Combining multiple datasets\nDatetime values have the format of YYYY-MM-DD hh: mm: ss format, so date and time are retained together. The following CAST statement returns a datetime value from a date.\nSELECT CAST (MyDate AS DATETIME) FROM MyTable\n\n3.2.0.1 The SAFE_CAST function\nUsing the CAST function in a query that fails returns an error in BigQuery. To avoid errors in the event of a failed query, use the SAFE_CAST function instead. The SAFE_CAST function returns a value of Null instead of an error when a query fails.\nSELECT SAFE_CAST(MyDate AS STRING) FROM MyTable\nReferences:\n\nCAST and CONVERT: SQL Server reference documentation\nMySQL CAST Functions and Operators: MySQL reference documentation\nHow to: SQL Type Casting: Blog about type casting that has links to other SQL short guides"
  },
  {
    "objectID": "code/2_converting_and_formatting.html#combining-strings-using-concat-in-sql",
    "href": "code/2_converting_and_formatting.html#combining-strings-using-concat-in-sql",
    "title": "3  Converting and formatting data",
    "section": "3.3 Combining strings using CONCAT in SQL",
    "text": "3.3 Combining strings using CONCAT in SQL\n\nSELECT \n    usertype,\n    --create a new column by combining to columns\n    CONCAT(start_station_name, \" to \", end_station_name) AS route,\n    --count number of rows to calculate the nr of trips\n    COUNT(*) AS num_trips,\n    --get average trip duration for each route\n    ROUND(AVG(CAST(tripduration AS int64)/60),2)\nFROM bigquery-public-data.new_york.citibike_trips\n--Since we're using COUNT and AVERAGE functions in our select clause, we have to use GROUP BY to group together summary rows\nGROUP BY start_station_name, end_station_name, usertype\n--- organize data to find the most common trips\nORDER BY num_trips DESC"
  },
  {
    "objectID": "code/2_converting_and_formatting.html#strings-in-spreadsheets",
    "href": "code/2_converting_and_formatting.html#strings-in-spreadsheets",
    "title": "3  Converting and formatting data",
    "section": "3.4 Strings in spreadsheets",
    "text": "3.4 Strings in spreadsheets\nLet’s build a simple formula to separate the dates in these strings. We know that LEN tells us the length of a string. Let’s check how long these datetime strings are now.\n=LEN(C2) tells us that the start-times contain 19 characters\nWe notice that all of the datetime strings have a space separating the date and the timestamp. So we can actually use FIND to figure out where the date ends.\n=FIND(\" \", C3) tells us that the space is the 11th character.\nWe can use the LEFT and RIGHT functions to select which parts of the string we want to isolate in a new column. We’ll use RIGHT on one of these cells to indicate that we want to grab the right side.\n=RIGHT(C2, 8) extracts the time (19 - 11 = 8)\n=LEFT(D3, 10) pulls out the date"
  },
  {
    "objectID": "code/2_converting_and_formatting.html#manipulating-strings-in-sql",
    "href": "code/2_converting_and_formatting.html#manipulating-strings-in-sql",
    "title": "3  Converting and formatting data",
    "section": "3.5 Manipulating strings in SQL",
    "text": "3.5 Manipulating strings in SQL\n\nCONCAT: A function that adds strings together to create new text strings that can be used as unique keys, i.e. CONCAT (<e2><80><98>Google<e2><80><99>, <e2><80><98>.com<e2><80><99>);\nCONCAT_WS: A function that adds two or more strings together with a separator, i.e. CONCAT_WS (<e2><80><98> . <e2><80><99>, <e2><80><98>www<e2><80><99>, <e2><80><98>google<e2><80><99>, <e2><80><98>com<e2><80><99>)\nCONCAT with +: Adds two or more strings together using the + operator, i.e. <e2><80><98>Google<e2><80><99> + <e2><80><98>.com<e2><80><99>\n\nW3 Schools is an excellent resource for interactive SQL learning, and the following links will guide you through transforming your data using SQL:\n\nSQL functions: This is a comprehensive list of functions to get you started. Click on each function, where you will learn about the definition, usage, examples, and even be able to create and run your own query for practice. Try it out for yourself!\n\nSQL Keywords: This is a helpful SQL keywords reference to bookmark as you increase your knowledge of SQL. This list of keywords are reserved words that you will use as your need to perform different operations in the database grows."
  },
  {
    "objectID": "code/2_converting_and_formatting.html#get-support-when-getting-stuck",
    "href": "code/2_converting_and_formatting.html#get-support-when-getting-stuck",
    "title": "3  Converting and formatting data",
    "section": "3.6 Get support when getting stuck",
    "text": "3.6 Get support when getting stuck\nResources:\n\nList of Google Sheets functions: This is a comprehensive list of the Google Sheets functions and syntax. Each function is listed with a link to learn more.\nList of spreadsheet functions: This is a comprehensive list of Excel spreadsheet functions with links to more detailed explanations. This is a useful resource to save so that you can reference it often; that way, you<80><99>ll have access to functions and examples that you can apply to your work.\nList of spreadsheet formulas: Similar to the previous resource, this comprehensive list of Excel spreadsheet formulas with links to more detailed explanations and can be saved and referenced any time you need to check out a formula for your analysis.\n\nStack Overflow is an online platform where programmers ask code-related questions and peers are available to suggest answers. You can ask questions about programming languages such as SQL and R (which you will learn about in Course 7), data tools, and much more. Follow the steps below to get started on Stack Overflow."
  },
  {
    "objectID": "code/3_aggregating_data.html",
    "href": "code/3_aggregating_data.html",
    "title": "4  Aggregating data",
    "section": "",
    "text": "Aggregation means collecting or gathering many separate pieces into a whole.\nData aggregation is the process of gathering data from multiple sources in order to combine it into a single summarized collection.\nIn data analytics, a summarized collection, or summary, describes identifying the data you need and gathering it all together in one place."
  },
  {
    "objectID": "code/3_aggregating_data.html#vlookup-spreadsheets",
    "href": "code/3_aggregating_data.html#vlookup-spreadsheets",
    "title": "4  Aggregating data",
    "section": "4.1 VLOOKUP (spreadsheets)",
    "text": "4.1 VLOOKUP (spreadsheets)\n\n4.1.1 Cleanup\nVALUE is a function that converts a text string that represents a number to a numerical value.\n=VALUE(A4)\nTRIM automatically deletes any extra spaces added to the cell.\n=TRIM(A4)\nRemove duplicates with remove duplictes\n\n\n4.1.2 VLOOKUP in action\nVLOOKUP stands for vertical lookup. Basically, it’s a function that searches for a certain value in a column to return a corresponding piece of information. The basic syntax looks like follows:\n=VLOOKUP(103, A2:B26, 2, FALSE)\nHere:\n\n103 is the value to search for\nA2:B26 is the range that will be searched\nVLOOKUP will not recognize column names such as A, B, or C. We use a number to indicate the column, i.e. we want to search for a match in the 2nd column that we want to add\nFALSE tells VLOOKUP to find an exact match. If this said true, the function will return only a close match\n\nAnother example for finding matching data in another sheet:\n=vlookup(A2, 'Employee Rates'!$A$2:$B$5,2, FALSE)\nBe sure to put single quotation marks around the spreadsheet name and add an exclamation point after it. This is the way to reference the other spreadsheet.\nWe can also search using words\n=VLOOKUP(\"Nigeria\", A2:C10, 2, false)\n\n\n4.1.3 Potential issues\n\nVLOOKUP only returns the first match it finds\nVLOOKUP can only return a value from the data to the right. It can’t look left. So for this to work, we have to move the data around\nLet’s say the first few rows of a VLOOKUP have returned the correct result. But when you drive the function down the column, problems start popping up. This is probably because the table array part of the function hasn’t been locked or made absolute. An absolute reference is a reference that is locked so that rows and columns won’t change when copied. You can fix this issue by wrapping the table array in dollar signs.\nLocking the spreadsheet. This stops other people from making changes and breaking functions.\nIf the spreadsheet needs to be shared you can use MATCH, which is a function used to locate the position of a specific lookup value and can help you with version control.\n\nResources:\n\nHow to use VLOOKUP in Excel: This tutorial includes a video to help you get a general understanding of how the VLOOKUP function works in Excel, as well as practical examples to look through.\nHow to use Excel’s VLOOKUP function: This article shares a specific example around how to apply VLOOKUP in your searches."
  },
  {
    "objectID": "code/3_aggregating_data.html#aggregating-in-sql",
    "href": "code/3_aggregating_data.html#aggregating-in-sql",
    "title": "4  Aggregating data",
    "section": "4.2 Aggregating in SQL",
    "text": "4.2 Aggregating in SQL\n\n4.2.1 The importance of aliases\nAliases are used in SQL queries to create temporary names for a column or table. Aliasing is the process of using aliases. In SQL queries, aliases are implemented by making use of the AS command and often make things more readable.\n\nSELECT column_name AS alias_name\nfrom table_name;\n\n\nSQL Aliases: This tutorial on aliasing is a really useful resource to have when you start practicing writing queries and aliasing tables on your own. It also demonstrates how aliasing works with real tables.\nSQL Alias: This detailed introduction to aliasing includes multiple examples. This is another great resource to reference if you need more examples.\nUsing Column Aliasing: This is a guide that focuses on column aliasing specifically. Generally, you will be aliasing entire tables, but if you find yourself needing to alias just a column, this is a great resource to have bookmarked.\n\n\n\n4.2.2 JOINs\nExamples were run in BiqQuery using data/employees_table.csv and data/departments_table.csv\nJOIN is a SQL clause that’s used to combine rows from two or more tables based on a related column.\nTypes of join:\n\n\nAn inner JOIN is a function that returns records with matching values in both tables. When we input JOIN into SQL, it usually defaults to inner JOIN\nA LEFT JOIN is a function that will return all the records from the left table and only the matching records from the right table.\nRIGHT JOIN does the opposite. It will return all records from the right table and only the matching records from the left.\nOUTER join combines RIGHT and LEFT JOIN to return all matching records in both tables. This means it will return all records in both tables.\n\nLet’s get a list of employees with their department name, excluding any employee without a department ID. the The department ID record is used in both tables, so we can use an INNER JOIN to return a list with only those employees.\n\nSELECT \n  --- give column names\n  employees.name AS employee_name,\n  employees.role AS employee_role,\n  departments.name AS department_name\nFROM \n  employee_data.employees\nINNER JOIN\n  employee_data.departments \n  ---specify which column and each table will contain the matching JOIN key \n  ON employees.department_id = departments.department_id\n\nNow, let’s try out one last JOIN: OUTER. OUTER JOIN will fetch all of the employee names and departments.\n\nSELECT \n  --- give column names\n  employees.name AS employee_name,\n  employees.role AS employee_role,\n  departments.name AS department_name\nFROM \n  employee_data.employees\nFULL OUTER JOIN\n  employee_data.departments \n  ---specify which column and each table will contain the matching JOIN key \n  ON employees.department_id = departments.department_id\n\nAnother example on the public dataset world_bank_intl_education\n\nSELECT \n    `bigquery-public-data.world_bank_intl_education.international_education`.country_name, \n    `bigquery-public-data.world_bank_intl_education.country_summary`.country_code, \n    `bigquery-public-data.world_bank_intl_education.international_education`.value\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education`\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` \nON `bigquery-public-data.world_bank_intl_education.country_summary`.country_code = `bigquery-public-data.world_bank_intl_education.international_education`.country_code\n\nThis basic query joins the tables on the country_code foreign key, and returns the country name, country code, and value column. This is quite a long, unwieldy query for such a basic result! The length of each table name (which must include the full address for each table for BigQuery to know where to pull the data from) makes this hard to read and work with.\nHowever, you can solve this by setting an alias for each table.\n\nSELECT \n    edu.country_name,\n    summary.country_code,\n    edu.value\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education` AS edu\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` AS summary\nON edu.country_code = summary.country_code\n\nNow that you<80><99>ve confirmed that the JOIN statement works, try to answer an actual data question using this dataset. What is the average amount of money spent per region on education? Copy, paste, and run the following query:\n\nSELECT \n    AVG(edu.value) average_value, summary.region\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education` AS edu\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` AS summary\nON edu.country_code = summary.country_code\nWHERE summary.region IS NOT null\nGROUP BY summary.region\nORDER BY average_value DESC\n\nResources:\n\nSQL JOINs: This is a good basic explanation of JOINs with examples. If you need a quick reminder of what the different JOINs do, this is a great resource to bookmark and come back to later.\n\nDatabase JOINs - Introduction to JOIN Types and Concepts: This is a really thorough introduction to JOINs. Not only does this article explain what JOINs are and how to use them, but it also explains the various scenarios in more detail of when and why you would use the different JOINs. This is a great resource if you are interested in learning more about the logic behind JOINing.\nSQL JOINs: Bringing Data Together One Join at a Time: Not only does this resource have a detailed explanation of JOINs with examples, but it also provides example data that you can use to follow along with their step-by-step guide. This is a useful way to practice JOINs with some real data.\nSQL JOIN: This is another resource that provides a clear explanation of JOINs and uses examples to demonstrate how they work. The examples also combine JOINs with aliasing. This is a great opportunity to see how JOINs can be combined with other SQL concepts that you have been learning about in this course."
  },
  {
    "objectID": "code/3_aggregating_data.html#count-and-count-distinct",
    "href": "code/3_aggregating_data.html#count-and-count-distinct",
    "title": "4  Aggregating data",
    "section": "4.3 COUNT and COUNT DISTINCT",
    "text": "4.3 COUNT and COUNT DISTINCT\nThese examples were run in BigQuery with data/warehouse.csv and data/orders.csv\nCOUNT is a query that returns the number of rows in a specified range, but COUNT DISTINCT is a little different. COUNT DISTINCT is a query that only returns the distinct values in that range.\nFrom this query, we’re actually going to start with a FROM statement so that we can alias our tables. Aliasing is when you temporarily name a table or column in your query to make it easier to read and write.\n\nSELECT \n  orders.*,\n  warehouse.warehouse_alias,\n  warehouse.state\n---create aliases for our tables\nFROM\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n\nNow, we want to count how many states are in our ordered data.\n\nSELECT \n  COUNT(warehouse.state) AS num_states\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n\nWait, that’s not quite right. This query returned over 9,000 states because we counted every single row that included a state. But we actually want to count the distinct states.\n\nSELECT \n  COUNT (DISTINCT warehouse.state) AS num_states\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n\nAccording to these results, we have three distinct states in our Orders data.\nLet’s check out what happens when we group by the state column in the warehouse table\n\nSELECT \n  warehouse.state AS state,\n  COUNT(DISTINCT order_id) AS num_orders\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\nGROUP BY \n  warehouse.state\n\nNow we have three rows, one of each state represented in the Orders data. And our COUNT DISTINCT on the number of orders sums up the count we ran earlier: 9,999."
  },
  {
    "objectID": "code/3_aggregating_data.html#subqueries",
    "href": "code/3_aggregating_data.html#subqueries",
    "title": "4  Aggregating data",
    "section": "4.4 Subqueries",
    "text": "4.4 Subqueries\nA subquery is a SQL query that is nested inside of a larger query.\nWith subqueries you can combine different pieces of logic together. Because the logic of your outer query relies on the inner query, you can get more done with a single query. This means all of the logic is in one place, which makes it more efficient and easier to read.\nThe statement containing the subquery can also be called the outer query or the outer select. This makes the subquery the inner query or inner select.\nThe inner query executes first so that the results can be passed on to the outer query to use.\nThere are a few rules that subqueries must follow:\n\nSubqueries must be enclosed within parentheses\nA subquery can have only one column specified in the SELECT clause. But if you want a subquery to compare multiple columns, those columns must be selected in the main query.\nSubqueries that return more than one row can only be used with multiple value operators, such as the IN operator which allows you to specify multiple values in a WHERE clause.\nA subquery can<80><99>t be nested in a SET command. The SET command is used with UPDATE to specify which columns (and values) are to be updated in a table.\n\n\n4.4.1 Examples\nThese examples you use the public data new_york and citibike_stations.\nFor the first statement, let’s say we want to compare the number of bikes available at a station to the average number of bikes available. We’re going to use this query to pull the average number of bikes available. Then we’re going to incorporate it as a subquery.\nWe want to select the station ID and the number of bikes available. Then we’ll put the SELECT query that’s pulling the average number of bikes inside that outer query by using parentheses.\n\nSELECT  \n  station_id, \n  num_bikes_available,\n  (SELECT\n    AVG(num_bikes_available)\n  FROM\n    bigquery-public-data.new_york_citibike.citibike_stations) AS avg_num_bikes_available\nFROM \n  bigquery-public-data.new_york_citibike.citibike_stations\n\nIt’s really common to see subqueries nested in FROM and WHERE statements. So let’s try those next. We could use a FROM statement to calculate the number of rides that have started at each station over time.\n\nSELECT\n  station_id,\n  name,\n  number_of_rides AS number_of_rides_starting_at_station\nFROM\n  (\n    SELECT start_station_id,\n      COUNT(*) AS number_of_rides\n    FROM bigquery-public-data.new_york_citibike.citibike_trips\n    GROUP BY start_station_id\n  )\n  AS station_num_trips\n  INNER JOIN\n\n  bigquery-public-data.new_york_citibike.citibike_stations ON station_id = start_station_id\n  ORDER BY number_of_rides DESC\n\nLet’s use a WHERE statement. The bike-sharing company has two kinds of users: subscribers and one-time customers. Let’s say we wanted a list of stations subscribers used.\n\nSELECT\n  station_id, \n  name\nFROM bigquery-public-data.new_york_citibike.citibike_stations\nWHERE \n  ---use IN so that we can specify multiple values and this WHERE statement\n  station_id IN\n  --- put subquery in parenthesis to tell we only want data on specific customers\n  (SELECT start_station_id\n  FROM bigquery-public-data.new_york_citibike.citibike_trips\n  WHERE usertype = 'Subscriber')"
  },
  {
    "objectID": "code/3_aggregating_data.html#using-subqueries-to-aggregate-data",
    "href": "code/3_aggregating_data.html#using-subqueries-to-aggregate-data",
    "title": "4  Aggregating data",
    "section": "4.5 Using subqueries to aggregate data",
    "text": "4.5 Using subqueries to aggregate data\nWe’ve used functions like WHERE to filter our data before, but the WHERE function can’t be used with aggregate functions. For example, you can use WHERE on a statement and follow it with GROUP BY.\nBut when you want to use GROUP BY first and then use WHERE on that output, you’ll need a different function. This is where HAVING comes in. HAVING basically allows you to add a filter to your query instead of the underlying table when you’re working with aggregate functions.\nSimilarly, CASE returns records with your conditions by allowing you to include if/then statements in your query.\nFor this example, we use the warehouse_orders previously loaded in BiqQuery\nWe’ve been asked to calculate what percentage of the orders are fulfilled by each warehouse. Basically, we’re interested in knowing which warehouses are delivering the most orders.\n\nSELECT \n  --- decide what to select (3rd)\n  Warehouse.warehouse_id,\n  ---use concat to get a unique warehouse name\n  CONCAT(Warehouse.state, \": \", Warehouse.warehouse_alias) AS warehouse_name,\n  --- get nr of orders per warehouse\n  COUNT(Orders.order_id) AS number_of_orders,\n  ---add subquery to pull the total nr of orders\n  (SELECT COUNT(*)\n    FROM warehouse_orders.Orders as Orders)\n    --- close subquery and name column\n    AS total_orders,\n    -- use a CASE statement to create categories for our warehouses\n    CASE \n      WHEN COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) <= 0.2\n      THEN \"filfilled 0-20% of Orders\"\n      WHEN COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) > 0.2\n      AND COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) <= 0.6\n      THEN \"fulfilled 21-60% of Orders\"\n    ELSE \"fulfilled more than 60% of Orders\"\n    END AS fulfillment_summary\n---add aliases (ideally write first to make the rest easier)\nFROM warehouse_orders.Warehouse AS Warehouse\n--- Join with orders and add alias (write second)\nLEFT JOIN warehouse_orders.Orders AS Orders ON Orders.warehouse_id = Warehouse.warehouse_id\nGROUP BY Warehouse.warehouse_id, warehouse_name\n--- remove orders from warehouses that are not yet running\nHAVING COUNT(Orders.order_id) > 0\n\nResources:\n\nSQL HAVING: This is an overview of the HAVING clause, including what it is and a tutorial on how and when it works.\nSQL CASE: Explore the usage of the CASE statement and examples of how it works.\nSQL IF: This is a tutorial of the IF function and offers examples that you can practice with.\nSQL COUNT: The COUNT function is just as important as all the rest, and this tutorial offers multiple examples to review.\nSQL subqueries: This detailed introduction includes the definition of a subquery, its purpose in SQL, when and how to use it, and what the results will be\nWriting subqueries in SQL: Explore the basics of subqueries in this interactive tutorial, including examples and practice problems that you can work through"
  },
  {
    "objectID": "code/4_data_calculations.html",
    "href": "code/4_data_calculations.html",
    "title": "5  Data calculations",
    "section": "",
    "text": "Some basic math examples to follow are here and here\nConditional functions are functions that perform a specific task, but only on cells that satisfy some defined criteria. They are usually identified with an IF suffix adjoined to the desired operation. They are frequently used when constructing more complex queries that cannot be accomplished using more basic functions.\n\n\nSome examples to follow are here\nCOUNTIF returns the number of cells that match a specified value.\n=COUNTIF(range, \"value\"), i.e. if we want to get values greater than 1 =COUNTIF(B2:B50, \">1\")\nCOUNTIFS allows you to create a COUNTIF function with multiple conditions. The basic syntax for COUNTIF is:\nCOUNTIFS(criteria_range1, criterion1, [criteria_range2, criterion2, ...])\n\n\n\nSUMIF is a function that adds numeric data based on one condition.\n=SUMIF(range, criteria/condition, [sum_range]). I.e. if we only want to sum things in column C if the quantity in colum B is 1, we do =SUMIF(B2:B50, \"1\", C2:C50)\nyou could also build in multiple conditions by using the SUMIFS function. SUMIF and SUMIFS are very similar, but SUMIFS can include multiple conditions. The basic syntax is:\n=SUMIFS(sum_range, criteria_range1, criterion1, [criteria_range2, criterion2, ...])\n\n\n\nThe MAXIFS function returns the maximum value among cells specified by a given set of conditions or criteria\nThe MAXIFS function is slightly different from the other three functions. The easiest way to observe the difference is to examine the syntax:\nThe MAXIFS function can input more than one constraint. This is where the optional range2 and constraint2 come into play.\n=MAXIFS(max_range, range1, criteria1, [range2], [criteria2], ...)\n\n\n\n\nHow to use the Excel IFS function: This resource includes an explanation and example of the IFS function in Excel. This is a great reference if you are interested in learning more about IFS. The example is a useful way to understand this function and how it can be used.\nVLOOKUP in Excel with multiple criteria: Similar to the previous resource, this resource goes into more detail about how to use VLOOKUP with multiple criteria. Being able to apply VLOOKUP with multiple criteria will be a useful skill, so check out this resource for more guidance on how you can start using it on your own spreadsheet data.\n\nINDEX and MATCH in Excel with multiple criteria: This resource explains how to use the INDEX and MATCH functions with multiple criteria. It also includes an example which helps demonstrate how these functions work with multiple criteria and actual data.\nUsing IF with AND, OR, and NOT functions in Excel: This resource combines IF with AND, OR, and NOT functions to create more complex functions. By combining these functions, you can perform your tasks more efficiently and cover more criteria at once.\n\n\n\n\nSUMPRODUCT is a function that multiplies arrays and returns the sum of those products. An array is kind of like a range in a spreadsheet. But keep in mind, an array is a collection of values in cells, not the cells themselves.\n=sumproduct(array1, [array2]...)\nTo check out the example, go here.\n\nSumproduct does all the calculations shown in the image above by doing the following:\n=sumproduct(B3:B7, C3:C7)\nThe profit margin is a percentage that indicates how many cents of profit have been generated for each dollar of sale. We can easily include this in our calculations:\n=SUMPRODUCT(B3:B7, C3:C7, D3:D7)"
  },
  {
    "objectID": "code/4_data_calculations.html#pivot-tables",
    "href": "code/4_data_calculations.html#pivot-tables",
    "title": "5  Data calculations",
    "section": "5.2 Pivot tables",
    "text": "5.2 Pivot tables\nPivot tables let you view data in multiple ways to find insights and trends. We’ve talked before about how pivot tables help with cleaning and organizing your data including sorting and grouping data. But pivot tables can also help with calculations. For example, they’re great for quickly calculating sums and averages.\nA pivot table has four basic parts: rows, columns, values, and filters.\n\nThe rows of a pivot table organize and group data you select horizontally.\nThe columns organize and display values from your data vertically. Similar to rows, columns can be pulled directly from the data set or created using values.\nValues are used to calculate and count data. This is where you input the variables you want to measure. This is also how you create calculated fields in your pivot table. As a refresher, a calculated field is a new field within a pivot table that carries out certain calculations based on the values of other fields\nhe filters section of a pivot table enables you to apply filters based on specific criteria <80><94> just like filters in regular spreadsheets\n\nThe example data can be found here and another example is here\n\nfind out how much revenue was generated each year\nbuild a pivot table to show this\nIn our pivot table, we can also find the average revenue per movie\ncheck our findings for some possible trends\n\n\nInsert –> Pivot table\nRename sheet\nRows –> release data to find revenue/year. To only get the year, right click somewhere in column A –> Create pivot date group –> year\nClick Add button for Values to add the box office revenue\nThis populates the columns next to the release dates with the total box office revenue and each year. These calculations are automatic because the pivot table is already set to summarize the data using the sum function\n\nNext, we add another column for the average revenue earned by each year’s movie\n\nAdd value –> Box office revenue and change sum to average\nWe see that one year, 2015, is particularly low and we might want to ask why\nAdd value –> Box office revenue and count function to see that 2015 was the year with the most movies but it still has a low box office revenue. Was it because none of the movies earned a lot of revenue?\nCp pivot table into A10 and rename the column names to distinguish this table from the old one\nSelect D11 and add a filter to box office revenue –> filter by condition –> less than –> 10,000,000\nWe see the whole table changing\nControl that the average values are still correct\nAdd value –> calculated field. A calculated field is a new field within a pivot table that carries out certain calculations based on the values of other fields.\nAdd =SUM('Box Office Revenue ($)'/count('Box Office Revenue ($)'))\n\nLet’s run a quick formula to find the percentage of movies for each year that earned less than $10 million. - Add header in G10 (a cell outside of the pivot table) - Divide the number of movies in the copy table by the number of movies in the original table"
  },
  {
    "objectID": "code/4_data_calculations.html#more-sql-calculations",
    "href": "code/4_data_calculations.html#more-sql-calculations",
    "title": "5  Data calculations",
    "section": "5.3 More SQL calculations",
    "text": "5.3 More SQL calculations\n\n5.3.1 Queries and calculations\nAn operator is a symbol that names the type of operation or calculation to be performed in a formula.\nThe syntax of a query is its structure. It should include all the specific details of the data you want to pull into a new table where those details should be placed.\n\nSELECT\n    columnA, \n    columnB\n    ColumnA + columnB AS columnX\nFROM tableX\n\nlet’s say you only wanted the remainder from a division calculation. Well, you need a different operator for this, the modulo operator. The modulo operator is represented by the percent symbol. This is an operator that returns the remainder when one number is divided by another.\nTo follow these examples below, we uploaded the data/avocado.csv data into BiqQuery.\nOur goal is to find out the total number of bags of avocados sold on each date at each location using this data. We want to make sure that the total column is just small, large, and extra-large bags added together.\n\nSELECT \n  Date, Region, Small_Bags, Large_Bags, XLarge_Bags, Total_Bags,\n  ---add the calculation to the query\n  Small_Bags + Large_Bags + XLarge_Bags AS total_bags_calc\nFROM avocado_data.avocado_prices\n\nNow that we have verified the total number of bags, we can use those values in another query. We need to find what percent of the total number of bags were small bags.\n\nSELECT \n  Date, Region, Total_Bags, Small_Bags,\n  ---find the percentage of small bags\n  (Small_Bags/ Total_Bags)*100 AS Small_bags_perc\nFROM avocado_data.avocado_prices\n\nThis gives an error: division by zero 0/0. This means that somewhere in the dataset there is total bags equal to zero. We’ll have to fix this in our query. We can fix this using the WHERE command. Using <> tells the server that the values we are calculating should not be equal to the value we specify. Alternatively, we could also use !=\n\nSELECT \n  Date, Region, Total_Bags, Small_Bags,\n  ---find the percentage of small bags\n  (Small_Bags/ Total_Bags)*100 AS Small_bags_perc\nFROM avocado_data.avocado_prices\nWHERE \n  Total_Bags <> 0\n\n\n\n5.3.2 Groupby\nGROUP BY is a command that groups rows that have the same values from a table into summary rows. The GROUP BY command is used with SELECT statements. In a basic SELECT FROM or SELECT-FROM-WHERE query, GROUP BY comes at the end of the query.\nThe EXTRACT command lets us pull one part of a given date to use.\nWe’ll work with a database, with data from a bike sharing system. We want to find out how many rides people took on these bikes per year.\n\nSELECT \n  ---extract year from the start time column\n  EXTRACT(YEAR FROM STARTTIME) AS year,\n  ---count the bike rides in the starttime column\n  COUNT(*) AS number_of_rides\nFROM bigquery-public-data.new_york.citibike_trips\n---group the data by year\nGROUP BY year\n--- organize the results\nORDER BY year\n\nLet’s try something else with the new_york_subway public dataset:\n\nOpen the bigquery-public-data dropdown in the Explorer menu and scroll until you find new_york_subway.\nOpen the dropdown and click subway_ridership_2013_present to open and examine the dataset.\nclick subway_ridership_2013_present to open and examine the dataset.\n\nThe change_2018_raw column describes the change in weekly ridership from 2017 to 2018 in raw numbers. Suppose you want to find data on the change in weekly ridership from 2013 to 2014. You can use SQL to subtract the number of riders in 2013 from the number of riders in 2014.\n\nSELECT \n  station_name, ridership_2013, ridership_2014,\n  ridership_2014 - ridership_2013 AS change_in_2014_raw\nFROM bigquery-public-data.new_york_subway.subway_ridership_2013_present\n\nThe original dataset describes average weekly ridership for each individual year. Suppose you want to find average weekly ridership for a longer period of time, such as the multi-year period from 2013-2016.\n\nSELECT \n  station_name, ridership_2013, ridership_2014, ridership_2015, ridership_2016,\n  (ridership_2013 + ridership_2014 + ridership_2015 + ridership_2016)/4 AS average\nFROM `bigquery-public-data.new_york_subway.subway_ridership_2013_present`"
  },
  {
    "objectID": "code/4_data_calculations.html#the-data-validation-process",
    "href": "code/4_data_calculations.html#the-data-validation-process",
    "title": "5  Data calculations",
    "section": "5.4 The data validation process",
    "text": "5.4 The data validation process\nThe data validation process involves checking and rechecking the quality of your data so that it is complete, accurate, secure, and consistent.\nIt is important that whenever you do calculations, you always check to make sure you’ve done them in the right way. Sometimes you’ll run data validation checks that are common-sense checks.\nThe following list outlines six types of data validation and the purpose of each, and includes examples and limitations.\n\nChecking that the data type is correct\nChecking that the data range is correct\nCheck that the data meets certain conditions or criteria for a field\nCheck that the data makes sense in the context of other related data, i.e. shipping dates should not be earlier than construction dates\nCheck that the data follows or conforms to a set structure, i.e. for MP3 files or HTML code\nCheck that the application code systematically performs any of the previously mentioned validations during user data input."
  },
  {
    "objectID": "code/4_data_calculations.html#sql-with-temporary-tables",
    "href": "code/4_data_calculations.html#sql-with-temporary-tables",
    "title": "5  Data calculations",
    "section": "5.5 SQL with temporary tables",
    "text": "5.5 SQL with temporary tables\nA temporary table is a database table that is created and exists temporarily on a database server.\n\nThey are automatically deleted from the database when you end your SQL session.\nThey can be used as a holding area for storing values if you are making a series of calculations. This is sometimes referred to as pre-processing of the data.\nThey can collect the results of multiple, separate queries. This is sometimes referred to as data staging. Staging is useful if you need to perform a query on the collected data or merge the collected data.\nThey can store a filtered subset of the database. You don<80><99>t need to select and filter the data each time you work with it. In addition, using fewer SQL commands helps to keep your data clean.\n\nThe WITH clause is a type of temporary table that you can query from multiple times. The WITH clause approximates a temporary table. Basically, this means it creates something that does the same thing as a temporary table.\nWhen you use temporary tables, you make your own work more efficient. Naming and using temp tables can help you deal with a lot of data in a more streamlined way, so you don’t get lost repeating query after query with the same code that you could just include in a temp table.\n\n---create temp table\nWITH trips_over_1_hr AS(\nSELECT *  \nFROM bigquery-public-data.new_york.citibike_trips\nWHERE tripduration >=60\n)\n\n-- count how many trips are 60+ minutes long\nSELECT \nCOUNT (*) AS cnt\nFROM trips_over_1_hr\n\nLets look at another example in the public austin_bikeshare\nConsider the following scenario: A bikeshare company has reached a recent milestone, and their marketing team wants to write a blog post that <80><9c>congratulates<80><9d> their most-used bike on being so popular. They want to include the name of the station that the bike is most likely to be found.\n\nWITH longest_used_bike AS (\n  SELECT bikeid,\n  SUM(duration_minutes) AS trip_duration\n  FROM `bigquery-public-data.austin_bikeshare.bikeshare_trips` \n  GROUP BY bikeid\n  ORDER BY trip_duration DESC\n  LIMIT 1\n)  \n\n--- find station with longest bikeshare ride started\nSELECT trips.start_station_id,\n  COUNT(*) AS trip_ct\nFROM longest_used_bike AS longest\nINNER JOIN `bigquery-public-data.austin_bikeshare.bikeshare_trips` AS trips\nON longest.bikeid = trips.bikeid\nGROUP BY trips.start_station_id\nORDER BY trip_ct DESC\nLIMIT 1\n\n\n5.5.1 Multiple table variations\nThe SELECT INTO statement is a good example of how to get a temp table done. This statement copies data from one table into a new table but it doesn’t add the new table to the database. It’s useful if you want to make a copy of a table with a specific condition, like a query with a WHERE clause\nUnfortunately, this command does not work in BigQuery so far.\nIf lots of people will be using the same table, then the CREATE TABLE statement might be the better option. This statement does add the table into the database."
  }
]