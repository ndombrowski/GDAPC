{
  "hash": "9c79ed9484e4f430596398a68a54dc65",
  "result": {
    "markdown": "---\nengine: knitr\nexecute: \n  eval: false\n---\n\n\n\n# Aggregating data\n\n- **Aggregation** means collecting or gathering many separate pieces into a whole. \n- **Data aggregation** is the process of gathering data from multiple sources in order to combine it into a single summarized collection. \n- In data analytics, **a summarized collection**, or summary, describes identifying the data you need and gathering it all together in one place. \n\n\n## VLOOKUP (spreadsheets)\n\n### Cleanup\n\n**VALUE** is a function that converts a text string that represents a number to a numerical value.\n\n`=VALUE(A4)`\n\n**TRIM** automatically deletes any extra spaces added to the cell.\n\n`=TRIM(A4)`\n\nRemove duplicates with `remove duplictes`\n\n\n### VLOOKUP in action\n\n**VLOOKUP** stands for vertical lookup. Basically, it's a function that searches for a certain value in a column to return a corresponding piece of information. The basic syntax looks like follows:\n\n`=VLOOKUP(103, A2:B26, 2, FALSE)`\n\nHere:\n\n- 103 is the value to search for\n- A2:B26 is the range that will be searched\n- VLOOKUP will not recognize column names such as A, B, or C. We use a number to indicate the column, i.e. we want to search for a match in the 2nd column that we want to add\n- FALSE tells VLOOKUP to find an exact match. If this said true, the function will return only a close match\n\nAnother example for finding matching data in another sheet:\n\n`=vlookup(A2, 'Employee Rates'!$A$2:$B$5,2, FALSE)`\n\nBe sure to put single quotation marks around the spreadsheet name and add an exclamation point after it. This is the way to reference the other spreadsheet.\n\nWe can also search using words\n\n`=VLOOKUP(\"Nigeria\", A2:C10, 2, false)`\n\n\n### Potential issues\n\n- VLOOKUP only returns the first match it finds\n- VLOOKUP can only return a value from the data to the right. It can't look left. So for this to work, we have to move the data around\n- Let's say the first few rows of a VLOOKUP have returned the correct result. But when you drive the function down the column, problems start popping up. This is probably because the table array part of the function hasn't been locked or made absolute. An **absolute reference** is a reference that is locked so that rows and columns won't change when copied. You can fix this issue by wrapping the table array in dollar signs.\n- Locking the spreadsheet. This stops other people from making changes and breaking functions.\n- If the spreadsheet needs to be shared you can use **MATCH**, which is a function used to locate the position of a specific lookup value and can help you with version control. \n\n\nResources:\n\n- [How to use VLOOKUP in Excel](https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1): This tutorial includes a video to help you get a general understanding of how the VLOOKUP function works in Excel, as well as practical examples to look through.\n- [How to use Excel's VLOOKUP function](https://edu.gcfglobal.org/en/excel-tips/how-to-use-excels-vlookup-function/1/): This article shares a specific example around how to apply VLOOKUP in your searches.\n\n\n## Aggregating in SQL\n\n### The importance of aliases\n\n**Aliases** are used in SQL queries to create temporary names for a column or table. Aliasing is the process of using aliases. In SQL queries, aliases are implemented by making use of the AS command and often make things more readable. \n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT column_name AS alias_name\nfrom table_name;\n```\n:::\n\n\n\n\n- [SQL Aliases](https://www.w3schools.com/sql/sql_alias.asp): This tutorial on aliasing is a really useful resource to have when you start practicing writing queries and aliasing tables on your own. It also demonstrates how aliasing works with real tables. \n- [SQL Alias](https://www.sqltutorial.org/sql-alias/): This detailed introduction to aliasing includes multiple examples. This is another great resource to reference if you need more examples. \n- [Using Column Aliasing](https://documentation.sas.com/?cdcId=pgmsascdc&cdcVersion=9.4_3.5&docsetId=sqlproc&docsetTarget=p0aymxwsvbt5wcn1lncugwjtf758.htm&locale=en): This is a guide that focuses on column aliasing specifically. Generally, you will be aliasing entire tables, but if you find yourself needing to alias just a column, this is a great resource to have bookmarked.  \n\n\n\n\n### JOINs\n\nExamples were run in BiqQuery using `data/employees_table.csv` and `data/departments_table.csv`\n\n**JOIN** is a SQL clause that's used to combine rows from two or more tables based on a related column.\n\nTypes of join:\n\n<img width=400 src=\"../images/joins.png\">\n\n- An inner JOIN is a function that returns records with matching values in both tables. When we input JOIN into SQL, it usually defaults to inner JOIN\n- A LEFT JOIN is a function that will return all the records from the left table and only the matching records from the right table. \n- RIGHT JOIN does the opposite. It will return all records from the right table and only the matching records from the left. \n- OUTER join combines RIGHT and LEFT JOIN to return all matching records in both tables. This means it will return all records in both tables.\n\nLet's get a list of employees with their department name, excluding any employee without a department ID. the The department ID record is used in both tables, so we can use an INNER JOIN to return a list with only those employees.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  --- give column names\n  employees.name AS employee_name,\n  employees.role AS employee_role,\n  departments.name AS department_name\nFROM \n  employee_data.employees\nINNER JOIN\n  employee_data.departments \n  ---specify which column and each table will contain the matching JOIN key \n  ON employees.department_id = departments.department_id\n```\n:::\n\n\n\nNow, let's try out one last JOIN: OUTER. OUTER JOIN will fetch all of the employee names and departments.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  --- give column names\n  employees.name AS employee_name,\n  employees.role AS employee_role,\n  departments.name AS department_name\nFROM \n  employee_data.employees\nFULL OUTER JOIN\n  employee_data.departments \n  ---specify which column and each table will contain the matching JOIN key \n  ON employees.department_id = departments.department_id\n```\n:::\n\n\n\nAnother example on the public dataset `world_bank_intl_education`\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n    `bigquery-public-data.world_bank_intl_education.international_education`.country_name, \n    `bigquery-public-data.world_bank_intl_education.country_summary`.country_code, \n    `bigquery-public-data.world_bank_intl_education.international_education`.value\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education`\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` \nON `bigquery-public-data.world_bank_intl_education.country_summary`.country_code = `bigquery-public-data.world_bank_intl_education.international_education`.country_code\n```\n:::\n\n\n\nThis basic query joins the tables on the country_code foreign key, and returns the country name, country code, and value column. This is quite a long, unwieldy query for such a basic result! The length of each table name (which must include the full address for each table for BigQuery to know where to pull the data from) makes this hard to read and work with. \n\nHowever, you can solve this by setting an alias for each table.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n    edu.country_name,\n    summary.country_code,\n    edu.value\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education` AS edu\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` AS summary\nON edu.country_code = summary.country_code\n```\n:::\n\n\n\nNow that you<e2><80><99>ve confirmed that the JOIN statement works, try to answer an actual data question using this dataset. What is the average amount of money spent per region on education? Copy, paste, and run the following query: \n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n    AVG(edu.value) average_value, summary.region\nFROM \n    `bigquery-public-data.world_bank_intl_education.international_education` AS edu\nINNER JOIN \n    `bigquery-public-data.world_bank_intl_education.country_summary` AS summary\nON edu.country_code = summary.country_code\nWHERE summary.region IS NOT null\nGROUP BY summary.region\nORDER BY average_value DESC\n```\n:::\n\n\n\n\nResources:\n\n- [SQL JOINs](https://www.w3schools.com/sql/sql_join.asp): This is a good basic explanation of JOINs with examples. If you need a quick reminder of what the different JOINs do, this is a great resource to bookmark and come back to later.  \n- [Database JOINs - Introduction to JOIN Types and Concepts](https://www.essentialsql.com/introduction-database-joins/): This is a really thorough introduction to JOINs. Not only does this article explain what JOINs are and how to use them, but it also explains the various scenarios in more detail of when and why you would use the different JOINs. This is a great resource if you are interested in learning more about the logic behind JOINing.\n- [SQL JOINs: Bringing Data Together One Join at a Time](https://towardsdatascience.com/sql-join-8212e3eb9fde): Not only does this resource have a detailed explanation of JOINs with examples, but it also provides example data that you can use to follow along with their step-by-step guide. This is a useful way to practice JOINs with some real data.\n- [SQL JOIN](https://www.dofactory.com/sql/join): This is another resource that provides a clear explanation of JOINs and uses examples to demonstrate how they work. The examples also combine JOINs with aliasing. This is a great opportunity to see how JOINs can be combined with other SQL concepts that you have been learning about in this course.  \n\n\n\n\n## COUNT and COUNT DISTINCT\n\nThese examples were run in BigQuery with `data/warehouse.csv` and `data/orders.csv`\n\n**COUNT** is a query that returns the number of rows in a specified range, but **COUNT DISTINCT** is a little different. COUNT DISTINCT is a query that only returns the distinct values in that range. \n\nFrom this query, we're actually going to start with a FROM statement so that we can alias our tables. **Aliasing** is when you temporarily name a table or column in your query to make it easier to read and write.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  orders.*,\n  warehouse.warehouse_alias,\n  warehouse.state\n---create aliases for our tables\nFROM\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n```\n:::\n\n\n\nNow, we want to count how many states are in our ordered data.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  COUNT(warehouse.state) AS num_states\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n```\n:::\n\n\n\nWait, that's not quite right. This query returned over 9,000 states because we counted every single row that included a state. But we actually want to count the distinct states. \n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  COUNT (DISTINCT warehouse.state) AS num_states\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\n```\n:::\n\n\n\nAccording to these results, we have three distinct states in our Orders data. \n\nLet's check out what happens when we group by the state column in the warehouse table\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  warehouse.state AS state,\n  COUNT(DISTINCT order_id) AS num_orders\nFROM\n---create aliases for our table\n  warehouse_orders.Orders AS orders\n--we need both the warehouse details and the order details because we want to report on the distribution of orders by state\nJOIN\n  warehouse_orders.Warehouse AS warehouse ON\n  orders.warehouse_id = warehouse.warehouse_id\nGROUP BY \n  warehouse.state\n```\n:::\n\n\n\nNow we have three rows, one of each state represented in the Orders data. And our COUNT DISTINCT on the number of orders sums up the count we ran earlier: 9,999.\n\n\n## Subqueries\n\nA **subquery** is a SQL query that is nested inside of a larger query. \n\nWith subqueries you can combine different pieces of logic together. Because the logic of your outer query relies on the inner query, you can get more done with a single query. This means all of the logic is in one place, which makes it more efficient and easier to read.\n\nThe statement containing the subquery can also be called the **outer query** or the outer select. This makes the subquery the **inner query** or inner select. \n\nThe inner query executes first so that the results can be passed on to the outer query to use. \n\nThere are a few rules that subqueries must follow:\n\n- Subqueries must be enclosed within parentheses\n- A subquery can have only one column specified in the SELECT clause. But if you want a subquery to compare multiple columns, those columns must be selected in the main query.\n- Subqueries that return more than one row can only be used with multiple value operators, such as the IN operator which allows you to specify multiple values in a WHERE clause.\n- A subquery can<e2><80><99>t be nested in a SET command. The SET command is used with UPDATE to specify which columns (and values) are to be updated in a table.\n\n### Examples\nThese examples you use the public data new_york and citibike_stations.\n\nFor the first statement, let's say we want to compare the number of bikes available at a station to the average number of bikes available. We're going to use this query to pull the average number of bikes available. Then we're going to incorporate it as a subquery.\n\nWe want to select the station ID and the number of bikes available. Then we'll put the SELECT query that's pulling the average number of bikes inside that outer query by using parentheses.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT  \n  station_id, \n  num_bikes_available,\n  (SELECT\n    AVG(num_bikes_available)\n  FROM\n    bigquery-public-data.new_york_citibike.citibike_stations) AS avg_num_bikes_available\nFROM \n  bigquery-public-data.new_york_citibike.citibike_stations\n```\n:::\n\n\n\nIt's really common to see subqueries nested in FROM and WHERE statements. So let's try those next. We could use a FROM statement to calculate the number of rides that have started at each station over time.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT\n  station_id,\n  name,\n  number_of_rides AS number_of_rides_starting_at_station\nFROM\n  (\n    SELECT start_station_id,\n      COUNT(*) AS number_of_rides\n    FROM bigquery-public-data.new_york_citibike.citibike_trips\n    GROUP BY start_station_id\n  )\n  AS station_num_trips\n  INNER JOIN\n\n  bigquery-public-data.new_york_citibike.citibike_stations ON station_id = start_station_id\n  ORDER BY number_of_rides DESC\n```\n:::\n\n\n\nLet's use a WHERE statement. The bike-sharing company has two kinds of users: subscribers and one-time customers. Let's say we wanted a list of stations subscribers used.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT\n  station_id, \n  name\nFROM bigquery-public-data.new_york_citibike.citibike_stations\nWHERE \n  ---use IN so that we can specify multiple values and this WHERE statement\n  station_id IN\n  --- put subquery in parenthesis to tell we only want data on specific customers\n  (SELECT start_station_id\n  FROM bigquery-public-data.new_york_citibike.citibike_trips\n  WHERE usertype = 'Subscriber')\n```\n:::\n\n\n\n\n## Using subqueries to aggregate data\n\nWe've used functions like WHERE to filter our data before, but the WHERE function can't be used with aggregate functions. For example, you can use WHERE on a statement and follow it with GROUP BY. \n\nBut when you want to use GROUP BY first and then use WHERE on that output, you'll need a different function. This is where HAVING comes in. **HAVING** basically allows you to add a filter to your query instead of the underlying table when you're working with aggregate functions. \n\nSimilarly, **CASE** returns records with your conditions by allowing you to include if/then statements in your query.\n\nFor this example, we use the warehouse_orders previously loaded in BiqQuery\n\nWe've been asked to calculate what percentage of the orders are fulfilled by each warehouse. Basically, we're interested in knowing which warehouses are delivering the most orders.\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  --- decide what to select (3rd)\n  Warehouse.warehouse_id,\n  ---use concat to get a unique warehouse name\n  CONCAT(Warehouse.state, \": \", Warehouse.warehouse_alias) AS warehouse_name,\n  --- get nr of orders per warehouse\n  COUNT(Orders.order_id) AS number_of_orders,\n  ---add subquery to pull the total nr of orders\n  (SELECT COUNT(*)\n    FROM warehouse_orders.Orders as Orders)\n    --- close subquery and name column\n    AS total_orders,\n    -- use a CASE statement to create categories for our warehouses\n    CASE \n      WHEN COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) <= 0.2\n      THEN \"filfilled 0-20% of Orders\"\n      WHEN COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) > 0.2\n      AND COUNT(Orders.order_id)/ (SELECT COUNT(*) FROM warehouse_orders.Orders AS Orders) <= 0.6\n      THEN \"fulfilled 21-60% of Orders\"\n    ELSE \"fulfilled more than 60% of Orders\"\n    END AS fulfillment_summary\n---add aliases (ideally write first to make the rest easier)\nFROM warehouse_orders.Warehouse AS Warehouse\n--- Join with orders and add alias (write second)\nLEFT JOIN warehouse_orders.Orders AS Orders ON Orders.warehouse_id = Warehouse.warehouse_id\nGROUP BY Warehouse.warehouse_id, warehouse_name\n--- remove orders from warehouses that are not yet running\nHAVING COUNT(Orders.order_id) > 0\n```\n:::\n\n\n\n\nResources:\n\n- [SQL HAVING](http://www-db.deis.unibo.it/courses/TW/DOCS/w3schools/sql/sql_having.asp.html): This is an overview of the HAVING clause, including what it is and a tutorial on how and when it works.\n- [SQL CASE](https://www.w3schools.com/sql/sql_case.asp): Explore the usage of the CASE statement and examples of how it works.\n- [SQL IF](https://www.w3schools.com/sql/func_mysql_if.asp): This is a tutorial of the IF function and offers examples that you can practice with.\n- [SQL COUNT](http://www-db.deis.unibo.it/courses/TW/DOCS/w3schools/sql/sql_func_count.asp.html): The COUNT function is just as important as all the rest, and this tutorial offers multiple examples to review.\n  \n- [SQL subqueries](https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php): This detailed introduction includes the definition of a subquery, its purpose in SQL, when and how to use it, and what the results will be\n- [Writing subqueries in SQL](https://mode.com/sql-tutorial/sql-sub-queries/): Explore the basics of subqueries in this interactive tutorial, including examples and practice problems that you can work through\n\n\n\n\n\n\n",
    "supporting": [
      "3_aggregating_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}