[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GDA: R programming",
    "section": "",
    "text": "In this course, you’ll learn about the programming language known as R. You’ll find out how to use RStudio, the environment that allows you to work with R. This course will also cover the software applications and tools that are unique to R, such as R packages. You’ll discover how R lets you clean, organize, analyze, visualize, and report data in new and more powerful ways.\nBy the end of this course, you will:\n\nExamine the benefits of using the R programming language.\nDiscover how to use RStudio to apply R to your analysis.\nExplore the fundamental concepts associated with programming in R.\nExplore the contents and components of R packages including the Tidyverse package.\nGain an understanding of dataframes and their use in R.\nDiscover the options for generating visualizations in R.\nLearn about R Markdown for documenting R programming."
  },
  {
    "objectID": "code/1_introduction.html",
    "href": "code/1_introduction.html",
    "title": "2  Introduction into (R) Programming",
    "section": "",
    "text": "Computer programming refers to giving instructions to a computer to perform an action or set of actions. Programming languages are the words and symbols we use to write instructions for computers to follow. Programming languages have their own set of rules for how these words and symbols should be used, called syntax. Coding is writing instructions to the computer in the syntax of a specific programming language.\nR is a programming language frequently used for statistical analysis, visualization and other data analysis. R is based on another programming language named S. In the 1970s, John Chambers created S for internal use at Bell Labs, a famous scientific research facility. The title R refers to the first names of its two authors and plays on a single- letter title of its predecessor S.\nRStudio’s an IDE or integrated development environment. This means that RStudio brings together all the tools you might want to use in a single place. There are two main ways of writing code in RStudio: using the console or using the source editor. You can type commands directly into the console, but they’ll be forgotten when you close your current session.\nPackages are units of reproducible R code. Members of the R community create packages to keep track of the R functions that they write and reuse. Packages offer a helpful combination of code, reusable R functions, descriptive documentation, tests for checking your code, and sample data sets.\nThe lubridate package that you are about to install is part of the tidyverse. The tidyverse is a collection of packages in R with a common design philosophy for data manipulation, exploration, and visualization. For a lot of data analysts, the tidyverse is an essential tool. You will learn more about the tidyverse later on in this course."
  },
  {
    "objectID": "code/1_introduction.html#installing-packages",
    "href": "code/1_introduction.html#installing-packages",
    "title": "2  Introduction into (R) Programming",
    "section": "2.1 Installing packages",
    "text": "2.1 Installing packages\n\ninstall.packages(\"tidyverse\")"
  },
  {
    "objectID": "code/1_introduction.html#loading-a-library",
    "href": "code/1_introduction.html#loading-a-library",
    "title": "2  Introduction into (R) Programming",
    "section": "2.2 Loading a library",
    "text": "2.2 Loading a library\n\n# | warning: false\nlibrary(tidyverse)"
  },
  {
    "objectID": "code/2_rstudio.html",
    "href": "code/2_rstudio.html",
    "title": "3  Programming using RStudio",
    "section": "",
    "text": "Functions are a body of reusable code used to perform specific tasks in R. Functions begin with function names like print or paste, and are usually followed by one or more arguments in parentheses. An argument is information that a function in R needs in order to run. I.e. print() will return whatever we include in the values in parentheses.\n\nprint(\"Coding in R\")\n\n[1] \"Coding in R\"\n\n\nIf you want to find out more about the print function or any function, all you have to do is type a question mark, the function name, and a set of parentheses. This returns a page in the Help window, which helps you learn more about the functions you’re working with. Keep in mind that functions are case-sensitive, so typing Print with a Capital P brings back an error message.\n\n?print()\n\nFunctions are great, but it can be pretty time-consuming to type out lots of values. To save time, we can use variables to represent the values. This lets us call out the values any time we need to with just the variable. A variable is a representation of a value in R that can be stored for use later during programming. Variables can also be called objects. A variable name should start with a letter and can also contain numbers and underscores.\n\n\n\nComments are helpful when you want to describe or explain what’s going on in your code. Use them as much as possible so that you and everyone can understand the reasoning behind it. Comments should be used to make an R script more readable. A comment shouldn’t be treated as code, so we’ll put a # in front of it. Then we’ll add our comment. Here’s an example of a variable.\n\n# Here is an example of a variable\nfirst_variable <- \"My variable\"\nfirst_variable\n\n[1] \"My variable\"\n\n\nAbove the <- is the assignment operator. It assigns the value to the variable.\n\n\n\nA data structure is a format for organizing and storing data. The most common data structures in the R programming language include:\n\nVectors\nData frames\nMatrices\nArrays\n\n\n\n\nA vector is a group of data elements of the same type stored in a sequence in R.\nThere are two types of vectors: atomic vectors and lists.\n\n\nThere are six primary types of atomic vectors:\n\nLogical: True/False\nInteger: Positive or negative whole values\nDouble: Decimal values\nCharacter: String/character values\nComplex\nRaw\n\nTogether, integer and double vectors are known as numeric vectors because they both contain numbers.\n\n\n\nYou can make a vector using the combined function. In R this function is just the letter c followed by the values you want in your vector inside parentheses, i.e. c()\n\nvec_1 <- c(13,48.5, 71, 101.5,2)\nvec_1\n\n[1]  13.0  48.5  71.0 101.5   2.0\n\n\n\n\n\nEvery vector you create will have two key properties: type and length.\nYou can determine what type of vector you are working with by using the typeof() function. Place the code for the vector inside the parentheses of the function. When you run the function, R will tell you the type. For example:\n\ntypeof(vec_1)\n\n[1] \"double\"\n\n\nYou can determine the length of an existing vector<80><93>meaning the number of elements it contains<80><93>by using the length() function.\n\nlength(vec_1)\n\n[1] 5\n\n\nYou can also check if a vector is a specific type by using an is function: is.logical(), is.double(), is.integer(), is.character().\n\nis.character(vec_1)\n\n[1] FALSE\n\n\n\n\n\nAll types of vectors can be named. Names are useful for writing readable code and describing objects in R. You can name the elements of a vector with the names() function.\n\n# create a vector\nx <- c(1, 3, 5)\n\n#assign names to each element of a vector\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n#view vector\nx\n\na b c \n1 3 5 \n\n\n\n\n\n\nLists are different from atomic vectors because their elements can be of any type<80><94>like dates, data frames, vectors, matrices, and more. Lists can even contain other lists.\nYou can create a list with the list() function. Similar to the c() function, the list() function is just list followed by the values you want in your list inside parentheses.\n\n\nIf you want to find out what types of elements a list contains, you can use the str() function. To do so, place the code for the list inside the parentheses of the function.\n\nstr(list(\"a\", 1L, 1.5, TRUE))\n\nList of 4\n $ : chr \"a\"\n $ : int 1\n $ : num 1.5\n $ : logi TRUE\n\n\nLet<80><99>s use the str() function to discover the structure of our second example. First, let<80><99>s assign the list to the variable z to make it easier to input in the str() function.\n\nz <- list(list(list(1 , 3, 5)))\nstr(z)\n\nList of 1\n $ :List of 1\n  ..$ :List of 3\n  .. ..$ : num 1\n  .. ..$ : num 3\n  .. ..$ : num 5\n\n\nThe indentation of the $ symbols reflect the nested structure of this list. Here, there are three levels (so there is a list within a list within a list).\n\n\n\nLists, like vectors, can be named. You can name the elements of a list when you first create it with the list() function:\n\nlist('Chicago' = 1, 'New York' = 2, 'Los Angeles' = 3)\n\n$Chicago\n[1] 1\n\n$`New York`\n[1] 2\n\n$`Los Angeles`\n[1] 3\n\n\n\n\n\n\nA matrix is a two-dimensional collection of data elements. This means it has both rows and columns. By contrast, a vector is a one-dimensional sequence of data elements. But like vectors, matrices can only contain a single data type. For example, you can<80><99>t have both logicals and numerics in a matrix.\nTo create a matrix in R, you can use the matrix() function. The matrix() function has two main arguments that you enter in the parentheses. First, add a vector. The vector contains the values you want to place in the matrix. Next, add at least one matrix dimension. You can choose to specify the number of rows or the number of columns by using the code nrow = or ncol =.\nFor example, imagine you want to create a 2x3 (two rows by three columns) matrix containing the values 3-8. First, enter a vector containing that series of numbers: c(3:8). Then, enter a comma. Finally, enter nrow = 2 to specify the number of rows.\n\nmatrix(c(3:8), nrow = 2)\n\n     [,1] [,2] [,3]\n[1,]    3    5    7\n[2,]    4    6    8\n\n\nYou can also choose to specify the number of columns (ncol = ) instead of the number of rows (nrow = ).\n\nmatrix(c(3:8), ncol = 2)\n\n     [,1] [,2]\n[1,]    3    6\n[2,]    4    7\n[3,]    5    8\n\n\n\n\n\nData frames are the most common way of storing and analyzing data in R, so it<80><99>s important to understand what they are and how to create them. A data frame is a collection of columns<80><93>similar to a spreadsheet or SQL table. Each column has a name at the top that represents a variable, and includes one observation per row. Data frames help summarize data and organize it into a format that is easy to read and use.\nThere are a few key things to keep in mind when you are working with data frames:\n\nColumns should be named.\nData frames can include many different types of data, like numeric, logical, or character.\nElements in the same column should be of the same type.\n\n\n\nIf you need to manually create a data frame in R, you can use the data.frame() function. The data.frame() function takes vectors as input. In the parentheses, enter the name of the column, followed by an equals sign, and then the vector you want to input for that column.\n\ndata.frame(x = c(1, 2, 3) , y = c(1.5, 5.5, 7.5))\n\n  x   y\n1 1 1.5\n2 2 5.5\n3 3 7.5"
  },
  {
    "objectID": "code/2_rstudio.html#files",
    "href": "code/2_rstudio.html#files",
    "title": "3  Programming using RStudio",
    "section": "3.2 Files",
    "text": "3.2 Files\nLet<80><99>s go over how to create, copy, and delete files in R. For more information on working with files in R.\nUse the dir.create function to create a new folder, or directory, to hold your files. Place the name of the folder in the parentheses of the function.\ndir.create (\"destination_folder\")\nUse the file.create() function to create a blank file. Place the name and the type of the file in the parentheses of the function. Your file types will usually be something like .txt, .docx, or .csv.\nfile.create (\"new_text_file.txt\")\nCopying a file can be done using the file.copy() function. In the parentheses, add the name of the file to be copied. Then, type a comma, and add the name of the destination folder that you want to copy the file to.\nfile.copy (\"new_text_file.txt\" , \"destination_folder\")\nYou can delete R files using the unlink() function. Enter the file<80><99>s name in the parentheses of the function.\nunlink (\"some_.file.csv\")"
  },
  {
    "objectID": "code/2_rstudio.html#pipes",
    "href": "code/2_rstudio.html#pipes",
    "title": "3  Programming using RStudio",
    "section": "3.3 Pipes",
    "text": "3.3 Pipes\nA pipe is a tool in R for expressing a sequence of multiple operations. A pipe is represented with %>%.It’s used to apply the output of one function into another function."
  },
  {
    "objectID": "code/2_rstudio.html#packages",
    "href": "code/2_rstudio.html#packages",
    "title": "3  Programming using RStudio",
    "section": "3.4 Packages",
    "text": "3.4 Packages\nPackages are units of reproducible R code, and they make it easier to keep track of code. They’re created by members of the R community to keep track of the R functions that they write and reuse\nPackages in R include reusable R functions and documentation about the functions, including how to use them. They also contain sample datasets and tests for checking your code to make sure it does what you want it to do.\nBy default, R includes a set of packages called Base R that are available to use in RStudio when you start your first programming session.\nTo check already installed packages we can type\n\npackages <- as.data.frame(installed.packages())\nhead(packages)\n\n                Package\nAlgDesign     AlgDesign\nAsioHeaders AsioHeaders\nDBI                 DBI\nFormula         Formula\nKernSmooth   KernSmooth\nMASS               MASS\n                                                                   LibPath\nAlgDesign   /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nAsioHeaders /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nDBI         /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nFormula     /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nKernSmooth  /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nMASS        /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n             Version    Priority\nAlgDesign      1.2.1        <NA>\nAsioHeaders 1.22.1-1        <NA>\nDBI            1.1.3        <NA>\nFormula        1.2-4        <NA>\nKernSmooth   2.23-20 recommended\nMASS          7.3-57 recommended\n                                                    Depends Imports LinkingTo\nAlgDesign                                              <NA>    <NA>      <NA>\nAsioHeaders                                            <NA>    <NA>      <NA>\nDBI                                   methods, R (>= 3.0.0)    <NA>      <NA>\nFormula                                 R (>= 2.0.0), stats    <NA>      <NA>\nKernSmooth                              R (>= 2.5.0), stats    <NA>      <NA>\nMASS        R (>= 3.3.0), grDevices, graphics, stats, utils methods      <NA>\n                                                                                                                                                 Suggests\nAlgDesign                                                                                                                                            <NA>\nAsioHeaders                                                                                                                                          <NA>\nDBI         blob, covr, DBItest, dbplyr, downlit, dplyr, glue, hms,\\nknitr, magrittr, RMariaDB, rmarkdown, rprojroot, RSQLite (>=\\n1.1-2), testthat, xml2\nFormula                                                                                                                                              <NA>\nKernSmooth                                                                                                                                  MASS, carData\nMASS                                                                                                                        lattice, nlme, nnet, survival\n            Enhances       License License_is_FOSS License_restricts_use\nAlgDesign       <NA>    GPL (>= 2)            <NA>                  <NA>\nAsioHeaders     <NA>       BSL-1.0            <NA>                  <NA>\nDBI             <NA> LGPL (>= 2.1)            <NA>                  <NA>\nFormula         <NA> GPL-2 | GPL-3            <NA>                  <NA>\nKernSmooth      <NA>     Unlimited            <NA>                  <NA>\nMASS            <NA> GPL-2 | GPL-3            <NA>                  <NA>\n            OS_type MD5sum NeedsCompilation Built\nAlgDesign      <NA>   <NA>              yes 4.2.0\nAsioHeaders    <NA>   <NA>               no 4.2.0\nDBI            <NA>   <NA>               no 4.2.0\nFormula        <NA>   <NA>               no 4.2.0\nKernSmooth     <NA>   <NA>              yes 4.2.1\nMASS           <NA>   <NA>              yes 4.2.1\n\n\nThe package column gives the name of the package like cluster or graphics. The priority column tells us what’s needed to use functions from the package. If you come across the word “base” in the priority column, then the package is already installed and loaded.\nPackages can be found in repositories, which are collections of useful packages that are ready to install. You can find repositories on Bioconductor, R-Forge, rOpenSci, or GitHub, but the most commonly used repository is the Comprehensive R Archive Network or CRAN. CRAN stores code and documentation so that you can install packages into your own RStudio space.\nConflicts happen when packages have functions with the same names as other functions. Basically, the last package loaded is the one whose functions will be used"
  },
  {
    "objectID": "code/2_rstudio.html#dates-and-times-in-r",
    "href": "code/2_rstudio.html#dates-and-times-in-r",
    "title": "3  Programming using RStudio",
    "section": "3.5 Dates and times in R",
    "text": "3.5 Dates and times in R\nIn this reading, you will learn how to work with dates and times in R using the lubridate package. Lubridate is part of tidyverse.\n\n#load required libs\nlibrary(tidyverse)\nlibrary(lubridate)\n\nIn R, there are three types of data that refer to an instant in time:\n\nA date (“2016-08-16”)\nA time within a day (“20:11:59 UTC”)\nAnd a date-time. This is a date plus a time (“2018-03-31 18:15:48 UTC”)\n\nFor example, to get the current date you can run the today() function. The date appears as year, month, and day.\n\ntoday()\n\n[1] \"2022-11-11\"\n\n\nTo get the current date-time you can run the now() function. Note that the time appears to the nearest second.\n\nnow()\n\n[1] \"2022-11-11 14:44:07 CET\"\n\n\nWhen working with R, there are three ways you are likely to create date-time formats:\n\nFrom a string\nFrom an individual date\nFrom an existing date/time object\n\nR creates dates in the standard yyyy-mm-dd format by default.\n\n3.5.1 Converting from strings\nDate/time data often comes as strings. You can convert strings into dates and date-times using the tools provided by lubridate. These tools automatically work out the date/time format. First, identify the order in which the year, month, and day appear in your dates. Then, arrange the letters y, m, and d in the same order. That gives you the name of the lubridate function that will parse your date.\n\nymd(\"2021-01-20\")\n\n[1] \"2021-01-20\"\n\n\nIt works the same way for any order. For example, month, day, and year. R still returns the date in yyyy-mm-dd format.\n\nmdy(\"January 20th, 2021\")\n\n[1] \"2021-01-20\"\n\n\nThese functions also take unquoted numbers and convert them into the yyyy-mm-dd format.\n\nymd(20210120)\n\n[1] \"2021-01-20\"\n\n\n\n\n3.5.2 Creating date-time components\nThe ymd() function and its variations create dates. To create a date-time from a date, add an underscore and one or more of the letters h, m, and s (hours, minutes, seconds) to the name of the function:\n\nymd_hms(\"2021-01-20 20:11:59\")\n\n[1] \"2021-01-20 20:11:59 UTC\"\n\n\n\nmdy_hm(\"01/20/2021 08:01\")\n\n[1] \"2021-01-20 08:01:00 UTC\"\n\n\n\n\n3.5.3 Optional: Switching between existing date-time objects\nFinally, you might want to switch between a date-time and a date.\nYou can use the function as_date() to convert a date-time to a date. For example, put the current date-time<80><94>now()<80><94>in the parentheses of the function.\n\nas_date(now())\n\n[1] \"2022-11-11\""
  },
  {
    "objectID": "code/2_rstudio.html#operators-and-calculations",
    "href": "code/2_rstudio.html#operators-and-calculations",
    "title": "3  Programming using RStudio",
    "section": "3.6 Operators and calculations",
    "text": "3.6 Operators and calculations\nOperators are defined as a symbol that names the type of operation or calculation to be performed in a formula. Arithmetic operators are used to complete math calculations.\nArithmetic operators let you perform basic math operations like addition, subtraction, multiplication, and division.\n\nIn the example above, we assume that x <- 2 and y <-5\n\nquarter_1_sales <- 35657.98\nquarter_2_sales <- 43810.55\nmidyear_sales <- quarter_1_sales + quarter_2_sales\nmidyear_sales\n\n[1] 79468.53\n\n\nLogical operators return a logical data type such as TRUE or FALSE. There are three primary types of logical operators:\n\nThe main difference between element-wise logical operators (&, |) and logical operators (&&, ||) is the way they apply to operations with vectors. The operations with double signs, AND (&&) and logical OR (||), only examine the first element of each vector. The operations with single signs, AND (&) and OR (|), examine all the elements of each vector.\n\nx <- c(3, 5, 7)\ny <- c(2, 4, 6)\n\nx < 5 & y < 5\n\n[1]  TRUE FALSE FALSE\n\n\n\nx < 5 && y < 5\n\n[1] TRUE\n\n\nRelational operators, also known as comparators, allow you to compare values. Relational operators identify how one R object relates to another<80><94>like whether an object is less than, equal to, or greater than another object. The output for relational operators is either TRUE or FALSE (which is a logical data type, or boolean).\n\nAssignment operators let you assign values to variables.\nIn many scripting programming languages you can just use the equal sign (=) to assign a variable. For R, the best practice is to use the arrow assignment (<-). Technically, the single arrow assignment can be used in the left or right direction. But the rightward assignment is not generally used in R code."
  },
  {
    "objectID": "code/2_rstudio.html#conditional-statements",
    "href": "code/2_rstudio.html#conditional-statements",
    "title": "3  Programming using RStudio",
    "section": "3.7 Conditional statements",
    "text": "3.7 Conditional statements\nA conditional statement is a declaration that if a certain condition holds, then a certain event must take place.\n\n3.7.1 if statement\nThe if statement sets a condition, and if the condition evaluates to TRUE, the R code associated with the if statement is executed.\nIn R, you place the code for the condition inside the parentheses of the if statement. The code that has to be executed if the condition is TRUE follows in curly braces (expr). Note that in this case, the second curly brace is placed on its own line of code and identifies the end of the code that you want to execute.\nif (condition) {\n expr\n}\n\nx <- 4\n\nif (x > 0) {\n    print(\"x is a positive number\")\n}\n\n[1] \"x is a positive number\"\n\n\nif you change x to a negative number, like -4, then the condition will be FALSE (-4 > 0). If you run the code, R will not execute the print statement. Instead, a blank line will appear as the result.\n\n\n3.7.2 else statement\nThe else statement is used in combination with an if statement. This is how the code is structured in R:\nif (condition) {\n  expr1\n} else {\n expr2\n}\nLet’s try the following:\n\nIf x is greater than 0, R will print <80><9c>x is a positive number<80><9d>.\nIf x is less than or equal to 0, R will print <80><9c>x is either a negative number or zero<80><9d>.\n\n\nx <- -7\n\nif (x > 0) {\n    print(\"x is a positive number\")\n} else {\n    print(\"x is either a negative number or zero\")\n}\n\n[1] \"x is either a negative number or zero\"\n\n\n\n\n3.7.3 else if statement\nIn some cases, you might want to customize your conditional statement even further by adding the else if statement. The else if statement comes in between the if statement and the else statement. This is the code structure:\nif (condition1) {\n expr1\n} else if (condition2) {\n expr2\n} else {\n expr3\n}\nIf the if condition (condition1) is met, then R executes the code in the first expression (expr1). If the if condition is not met, and the else if condition (condition2) is met, then R executes the code in the second expression (expr2). If neither of the two conditions are met, R executes the code in the third expression (expr3).\nIn our previous example, using only the if and else statements, R can only print <80><9c>x is either a negative number or zero<80><9d> if x equals 0 or x is less than zero. Imagine you want R to print the string <80><9c>x is zero<80><9d> if x equals 0. You need to add another condition using the else if statement.\n\nx <- -1\n\nif (x < 0) {\n    print(\"x is a negative number\")\n} else if (x == 0) {\n    print(\"x is zero\")\n} else {\n    print(\"x is a positive number\")\n}\n\n[1] \"x is a negative number\""
  },
  {
    "objectID": "code/2_rstudio.html#keeping-your-code-readable",
    "href": "code/2_rstudio.html#keeping-your-code-readable",
    "title": "3  Programming using RStudio",
    "section": "3.8 Keeping Your Code Readable",
    "text": "3.8 Keeping Your Code Readable\n\nFile names should be meaningful\nAvoid using special characters in file names<80><94>stick with numbers,letters, dashes, and underscores.\nVariable and function names should be lowercase. Use an underscore _ to separate words within a name. Try to create names that are clear, concise, and meaningful.\nMost operators (== , + , - , <- ,etc.) should be surrounded by spaces.\nAlways put a space after a comma (never before).\nDo not place spaces around code in parentheses or square brackets (unless there<80><99>s a comma, in which case see above).\nAn opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line (unless it<80><99>s followed by an else statement). Always indent the code inside curly braces.\nWhen indenting your code, use two spaces. Do not use tabs or mix tabs and spaces.\nTry to limit your code to 80 characters per line. This fits nicely on a printed page with a reasonably sized font.\nUse <- , not = , for assignment.\nEntire commented lines should begin with the comment symbol and a single space: #."
  },
  {
    "objectID": "code/2_rstudio.html#viewing-data",
    "href": "code/2_rstudio.html#viewing-data",
    "title": "3  Programming using RStudio",
    "section": "3.9 Viewing data",
    "text": "3.9 Viewing data\nMany of the tidyverse packages contain sample datasets that you can use to practice your R skills. The diamonds dataset in the ggplot2 package is a great example for previewing R functions.\n\nhead(diamonds)\n\n# A tibble: 6 x 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\nIn addition to head() there are a number of other useful functions you can use to summarize or preview the data. For example, the str() and glimpse() functions will both return summaries of each column in your data arranged horizontally. You can try out these two functions by running the code chunks below:\n\nstr(diamonds)\n\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n\n\n\nglimpse(diamonds)\n\nRows: 53,940\nColumns: 10\n$ carat   <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.~\n$ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver~\n$ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,~\n$ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, ~\n$ depth   <dbl> 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64~\n$ table   <dbl> 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58~\n$ price   <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34~\n$ x       <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.~\n$ y       <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.~\n$ z       <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.~\n\n\nAnother simple function that you may use regularly is the colnames() function. It returns a list of column names from your dataset. You can check out this function by running the code chunk below:\n\ncolnames(diamonds)\n\n [1] \"carat\"   \"cut\"     \"color\"   \"clarity\" \"depth\"   \"table\"   \"price\"  \n [8] \"x\"       \"y\"       \"z\""
  },
  {
    "objectID": "code/2_rstudio.html#cleaning-data",
    "href": "code/2_rstudio.html#cleaning-data",
    "title": "3  Programming using RStudio",
    "section": "3.10 Cleaning data",
    "text": "3.10 Cleaning data\nOne of the most frequent tasks you will have to perform as an analyst is to clean and organize your data. R makes this easy! There are many functions you can use to help you perform important tasks easily and quickly.\nFor example, you might need to rename the columns, or variables, in your data. There is a function for that: rename(). You can check out how it works in the chunk below:\n\nrename(diamonds, carat_new = carat)\n\n# A tibble: 53,940 x 10\n   carat_new cut       color clarity depth table price     x     y     z\n       <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1      0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2      0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3      0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4      0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5      0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6      0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7      0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8      0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9      0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10      0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ... with 53,930 more rows\n\n\nYou can rename more than one variable in the same rename() code. The code below demonstrates how:\n\nrename(diamonds, carat_new = carat, cut_new = cut)\n\n# A tibble: 53,940 x 10\n   carat_new cut_new   color clarity depth table price     x     y     z\n       <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1      0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2      0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3      0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4      0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5      0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6      0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7      0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8      0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9      0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10      0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ... with 53,930 more rows\n\n\nAnother handy function for summarizing your data is summarize(). You can use it to generate a wide range of summary statistics for your data. For example, if you wanted to know what the mean for carat was in this dataset, you could run the code in the chunk below:\n\nsummarize(diamonds, mean_carat = mean(carat))\n\n# A tibble: 1 x 1\n  mean_carat\n       <dbl>\n1      0.798"
  },
  {
    "objectID": "code/2_rstudio.html#visualizing-data",
    "href": "code/2_rstudio.html#visualizing-data",
    "title": "3  Programming using RStudio",
    "section": "3.11 Visualizing data",
    "text": "3.11 Visualizing data\nWith R, you can create data visualizations that are simple and easy to understand or complicated and beautiful just by changing a bit of code. R empowers you to present the same data in so many different ways, which can help you create new insights or highlight important data findings. One of the most commonly used visualization packages is the ggplot2 package, which is loaded automatically when you install and load tidyverse.\nTo build a visualization with ggplot2 you layer plot elements together with a + symbol. You will learn a lot more about using ggplot2 later in the course, but here is a preview of how easy and flexible it is to make visuals using code:\n\nggplot(data = diamonds, aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\nThe code above takes the diamonds data, plots the carat column on the X-axis, the price column on the Y-axis, and represents the data as a scatter plot using the geom_point() command.\nggplot2 makes it easy to modify or improve your visuals. For example, if you wanted to change the color of each point so that it represented another variable, such as the cut of the diamond, you can change the code like this:\n\nggplot(data = diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point()\n\n\n\n\nSometimes when you are trying to represent many different aspects of your data in a visual, it can help to separate out some of the components. For example, you could create a different plot for each type of cut. ggplot2 makes it easy to do this with the facet_wrap() function:\n\nggplot(data = diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point() +\n    facet_wrap(~cut)"
  },
  {
    "objectID": "code/2_rstudio.html#the-tidyverse",
    "href": "code/2_rstudio.html#the-tidyverse",
    "title": "3  Programming using RStudio",
    "section": "3.12 The tidyverse",
    "text": "3.12 The tidyverse\nTidyverse is actually a collection of packages in R with a common design philosophy for data manipulation, exploration, and visualization.\nThe packages are ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr, and forcats.\n\nreadr is used for importing data\nGgplot2 is used for data visualization, specifically plots. With ggplot2, you can create a variety of data viz by applying different visual properties to the data variables.\nTidyr is a package used for data cleaning to make tidy data\nDplyr offers a consistent set of functions that help you complete some common data manipulation tasks. For example, the select function picks variables based on their names, and the filter function finds cases where certain conditions are true\nTibble works with data frames.\nPurrr works with functions and vectors helping make your code easier to write and more expressive.\nStringr includes functions that make it easier to work with strings.\nForcats provides tools that solve common problems with factors. As a quick reminder, factors store categorical data in R where the data values are limited and usually based on a finite group like country or year.\n\n\n3.12.1 Checking for updates\n\n#tidyverse_update()\n\n\n\n3.12.2 Read tidyverse vignettes\nA vignette is documentation that acts as a guide to an R package. A vignette shares details about the problem that the package is designed to solve and how the included functions can help you solve it. The browseVignettes function allows you to read through vignettes of a loaded package.\n\n#browseVignettes(\"ggplot2\")\n\n\n\n3.12.3 Working with pipes\nNested describes code that performs a particular function and is contained within code that performs a broader function.\n\n#load an already installed dataset\ndata(\"ToothGrowth\")\nhead(ToothGrowth)\n\n   len supp dose\n1  4.2   VC  0.5\n2 11.5   VC  0.5\n3  7.3   VC  0.5\n4  5.8   VC  0.5\n5  6.4   VC  0.5\n6 10.0   VC  0.5\n\n\nNow, let’s say we need to filter and sort this data to organize it for analysis.\n\n#apply the filter fct from the dplyr package\n#to only include rows were the dose of vitamin is 0.5\nfiltered_tg <- filter(ToothGrowth, dose == 0.5)\n\n#check dimensions\ndim(ToothGrowth)\n\n[1] 60  3\n\ndim(filtered_tg)\n\n[1] 20  3\n\n\nNext, lets sort the data with the arrange() fct.\n\n#first we have the df, then the column we want to sort by\narrange(filtered_tg, len)\n\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n\n\nLet’s now use a nested function to do this:\n\narrange(filter(ToothGrowth, dose == 0.5), len)\n\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n\n\nNotice that the filter function from our previous code is the nested function. With nested functions, we read from the inside out. The code filters the data first. Then it arranges or sorts it.\nNow, let’s use a pipe:\nThe shortcut to enter a pipe is cmd+shift+m\n\nfiltered_toothgrowh <- ToothGrowth |> \n    filter(dose==0.5) |> \n    arrange(len)\n\nfiltered_toothgrowh\n\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n\n\nBuilding on our example, let’s say we also wanted to compute the average tooth length or len for each of the two supplements used in the study: orange juice or OJ and ascorbic acid or VC.\n\nfiltered_toothgrowh <- ToothGrowth |> \n    filter(dose==0.5) |> \n    #group by tooth supplements\n    group_by(supp) |> \n    #summarize data by group\n    summarise(mean_len = mean(len, na.rm = T), .group = \"drop\")\n\nfiltered_toothgrowh\n\n# A tibble: 2 x 3\n  supp  mean_len .group\n  <fct>    <dbl> <chr> \n1 OJ       13.2  drop  \n2 VC        7.98 drop"
  },
  {
    "objectID": "code/3_data_in_R.html",
    "href": "code/3_data_in_R.html",
    "title": "4  Data in R",
    "section": "",
    "text": "A data frame is a collection of columns. Some rules: - columns should be named - data stored in your data frame can be many different types, like numeric, factor, or character - each column should contain the same number of data items, even if some of those data items are missing\nTibbles are like streamlined data frames. They make working with data easier, but they’re a little different from standard data frames: - tibbles never change the data types of the inputs. They won’t change your strings to factors or anything else - You can make more changes to base data frames, but tibbles are easier to use. This saves time because you won’t have to do as much cleaning or changing data types in tibbles. - Tibbles also never change the names of your variables, and they never create row names - tibbles make printing in R easier. They won’t accidentally overload your console because they’re automatically set to pull up only the first 10 rows and as many columns as fit on screen\nTidy data standards:\n\nVariables are organized into columns\nObservations are organized into rows\nEach value must have its own cell\n\n\n#load libs\nlibrary(\"tidyverse\")\n\n\n#load data\ndata(\"diamonds\")\n\n#view the first six rows\nhead(diamonds)\n\n# A tibble: 6 x 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\n\n#get the structure\nstr(diamonds)\n\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n\n\n\n#print column names\ncolnames(diamonds)\n\n [1] \"carat\"   \"cut\"     \"color\"   \"clarity\" \"depth\"   \"table\"   \"price\"  \n [8] \"x\"       \"y\"       \"z\"      \n\n\nNext, lets use the mutate function to make changes to our data frame. The mutate function is part of the dplyr package which is in the tidyverse.\n\n#add a new column\ndf <- mutate(diamonds, carat_2 = carat * 100)\nhead(df)\n\n# A tibble: 6 x 11\n  carat cut       color clarity depth table price     x     y     z carat_2\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>   <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43      23\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31      21\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31      23\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63      29\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75      31\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48      24\n\n\n\n\n\n#create some vectors\nnames <- c(\"Julia\", \"Peter\", \"Leo\", \"Sara\")\nage <- c(21,14, 17,50 )\n\n#create and view df\npeople <- data.frame(names, age)\npeople\n\n  names age\n1 Julia  21\n2 Peter  14\n3   Leo  17\n4  Sara  50\n\n\nNow that you have a data frame, you can work with it using all of the tools in R. For example, you could use mutate() if you wanted to create a new variable that would capture each person’s age in twenty years. The code chunk below creates that new variable:\n\nmutate(people, age_in_20 = age + 20)\n\n  names age age_in_20\n1 Julia  21        41\n2 Peter  14        34\n3   Leo  17        37\n4  Sara  50        70\n\n\n\n\n\nWe can easily create tibbles from data sets as follows:\n\nstr(as_tibble(diamonds))\n\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ..."
  },
  {
    "objectID": "code/3_data_in_R.html#data-import",
    "href": "code/3_data_in_R.html#data-import",
    "title": "4  Data in R",
    "section": "4.2 Data import",
    "text": "4.2 Data import\n\n4.2.1 The data() function\nThe default installation of R comes with a number of preloaded datasets that you can practice with. You can use the data() function to load these datasets in R. If you run the data function without an argument, R will display a list of the available datasets. If you want to load a specific dataset, just enter its name in the parentheses of the data() function, i.e. data(mtcars).\n\n\n4.2.2 readr\nThe goal of readr is to provide a fast and friendly way to read rectangular data. readr supports several read_ functions. Each function refers to a specific file format.\n\nread_csv(): comma separated (CSV) files\nread_tsv(): tab separated files\nread_delim(): general delimited files\nread_fwf(): fixed width files\nread_table(): tabular files where columns are separated by white-space\nread_log(): web log files\n\nThe readr package comes with some sample files from built-in datasets that you can use for example code. To list the sample files, you can run the readr_example() function with no arguments.\n\nreadr_example()\n\n [1] \"challenge.csv\"               \"chickens.csv\"               \n [3] \"epa78.txt\"                   \"example.log\"                \n [5] \"fwf-sample.txt\"              \"massey-rating.txt\"          \n [7] \"mini-gapminder-africa.csv\"   \"mini-gapminder-americas.csv\"\n [9] \"mini-gapminder-asia.csv\"     \"mini-gapminder-europe.csv\"  \n[11] \"mini-gapminder-oceania.csv\"  \"mtcars.csv\"                 \n[13] \"mtcars.csv.bz2\"              \"mtcars.csv.zip\"             \n[15] \"whitespace-sample.txt\"      \n\n\nLet’s try to read in a table:\n\nread_csv(readr_example(\"mtcars.csv\"))\n\n# A tibble: 32 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ... with 22 more rows\n\n\n\n\n4.2.3 readxl\nTo import spreadsheet data into R, you can use the readxl package. The readxl package is part of the tidyverse but is not a core tidyverse package, so you need to load readxl in R by using the library() function.\n\nlibrary(readxl)\n\nLets check out example files first:\n\nreadxl_example()\n\n [1] \"clippy.xls\"    \"clippy.xlsx\"   \"datasets.xls\"  \"datasets.xlsx\"\n [5] \"deaths.xls\"    \"deaths.xlsx\"   \"geometry.xls\"  \"geometry.xlsx\"\n [9] \"type-me.xls\"   \"type-me.xlsx\" \n\n\nNow, lets read in one of those examples:\n\nread_excel(readxl_example(\"type-me.xlsx\"))\n\n# A tibble: 10 x 2\n   `maybe boolean?` description                         \n   <chr>            <chr>                               \n 1 <NA>             \"empty\"                             \n 2 0                \"0 (numeric)\"                       \n 3 1                \"1 (numeric)\"                       \n 4 40908            \"datetime\"                          \n 5 TRUE             \"boolean true\"                      \n 6 FALSE            \"boolean false\"                     \n 7 cabbage          \"\\\"cabbage\\\"\"                       \n 8 true             \"the string \\\"true\\\"\"               \n 9 F                \"the letter \\\"F\\\"\"                  \n10 False            \"\\\"False\\\" preceded by single quote\"\n\n\nYou can use the excel_sheets() function to list the names of the individual sheets.\n\nexcel_sheets(readxl_example(\"type-me.xlsx\"))\n\n[1] \"logical_coercion\" \"numeric_coercion\" \"date_coercion\"    \"text_coercion\"   \n\n\nYou can also specify a sheet by name or number.\n\nread_excel(readxl_example(\"type-me.xlsx\"), sheet = \"numeric_coercion\")\n\n# A tibble: 7 x 2\n  `maybe numeric?` explanation            \n  <chr>            <chr>                  \n1 <NA>             \"empty\"                \n2 TRUE             \"boolean true\"         \n3 FALSE            \"boolean false\"        \n4 40534            \"datetime\"             \n5 123456           \"the string \\\"123456\\\"\"\n6 123456           \"the number 123456\"    \n7 cabbage          \"\\\"cabbage\\\"\"          \n\n\n\n\n4.2.4 Practice\nRead in a dataset\n\nbookings_df <- read_csv(\"../data/hotel_bookings.csv\")\nhead(bookings_df)\n\n# A tibble: 6 x 32\n  hotel   is_ca~1 lead_~2 arriv~3 arriv~4 arriv~5 arriv~6 stays~7 stays~8 adults\n  <chr>     <dbl>   <dbl>   <dbl> <chr>     <dbl>   <dbl>   <dbl>   <dbl>  <dbl>\n1 Resort~       0     342    2015 July         27       1       0       0      2\n2 Resort~       0     737    2015 July         27       1       0       0      2\n3 Resort~       0       7    2015 July         27       1       0       1      1\n4 Resort~       0      13    2015 July         27       1       0       1      1\n5 Resort~       0      14    2015 July         27       1       0       2      2\n6 Resort~       0      14    2015 July         27       1       0       2      2\n# ... with 22 more variables: children <dbl>, babies <dbl>, meal <chr>,\n#   country <chr>, market_segment <chr>, distribution_channel <chr>,\n#   is_repeated_guest <dbl>, previous_cancellations <dbl>,\n#   previous_bookings_not_canceled <dbl>, reserved_room_type <chr>,\n#   assigned_room_type <chr>, booking_changes <dbl>, deposit_type <chr>,\n#   agent <chr>, company <chr>, days_in_waiting_list <dbl>,\n#   customer_type <chr>, adr <dbl>, required_car_parking_spaces <dbl>, ...\n\n\nIf you want to create another data frame using bookings_df that focuses on the average daily rate, which is referred to as adr in the data frame, and adults, you can use the following code chunk to do that:\n\nnew_df <- select(bookings_df, adr, adults)\nhead(new_df)\n\n# A tibble: 6 x 2\n    adr adults\n  <dbl>  <dbl>\n1     0      2\n2     0      2\n3    75      1\n4    75      1\n5    98      2\n6    98      2\n\n\nTo create new variables in your data frame, you can use the mutate() function. This will make changes to the data frame, but not to the original data set you imported. That source data will remain unchanged.\n\nmutate(new_df, total = adr/adults)\n\n# A tibble: 119,390 x 3\n     adr adults total\n   <dbl>  <dbl> <dbl>\n 1    0       2   0  \n 2    0       2   0  \n 3   75       1  75  \n 4   75       1  75  \n 5   98       2  49  \n 6   98       2  49  \n 7  107       2  53.5\n 8  103       2  51.5\n 9   82       2  41  \n10  106.      2  52.8\n# ... with 119,380 more rows"
  },
  {
    "objectID": "code/3_data_in_R.html#cleaning-data",
    "href": "code/3_data_in_R.html#cleaning-data",
    "title": "4  Data in R",
    "section": "4.3 Cleaning data",
    "text": "4.3 Cleaning data\n\n4.3.1 Naming conventions\nDo’s\n\nKeep your filenames to a reasonable length\nUse underscores and hyphens for readability\nStart or end your filename with a letter or number\nUse a standard date format when applicable; example: YYYY-MM-DD\nUse filenames for related files that work well with default ordering; example: in chronological order, or logical order using numbers first\n\nDon’t\n\nUse unnecessary additional characters in filenames\nUse spaces or <80><9c>illegal<80><9d> characters; examples: &, %, #, <, or >\nStart or end your filename with a symbol\nUse incomplete or inconsistent date formats; example: M-D-YY\nUse filenames for related files that do not work well with default ordering; examples: a random system of numbers or date formats, or using letters first\n\n\n\n4.3.2 Data exploration\nSome useful packages:\n\nThe Here package makes referencing files easier\nThe Skimr package makes summarizing data really easy and let’s you skim through it more quickly\nThe Janitor package has functions for cleaning data.\n\n\n#load libs\nlibrary(palmerpenguins)\nlibrary(here)\nlibrary(skimr)\nlibrary(janitor)\n\nSome useful functions are:\n\nskim_without_charts()\nglimpse()\nselect()\n\n\n#summarize data \nskim_without_charts(penguins)\n\n\nData summary\n\n\nName\npenguins\n\n\nNumber of rows\n344\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n3\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nspecies\n0\n1.00\nFALSE\n3\nAde: 152, Gen: 124, Chi: 68\n\n\nisland\n0\n1.00\nFALSE\n3\nBis: 168, Dre: 124, Tor: 52\n\n\nsex\n11\n0.97\nFALSE\n2\nmal: 168, fem: 165\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\nbill_length_mm\n2\n0.99\n43.92\n5.46\n32.1\n39.23\n44.45\n48.5\n59.6\n\n\nbill_depth_mm\n2\n0.99\n17.15\n1.97\n13.1\n15.60\n17.30\n18.7\n21.5\n\n\nflipper_length_mm\n2\n0.99\n200.92\n14.06\n172.0\n190.00\n197.00\n213.0\n231.0\n\n\nbody_mass_g\n2\n0.99\n4201.75\n801.95\n2700.0\n3550.00\n4050.00\n4750.0\n6300.0\n\n\nyear\n0\n1.00\n2008.03\n0.82\n2007.0\n2007.00\n2008.00\n2009.0\n2009.0\n\n\n\n\n\nFirst, it gives us a summary with the name of the dataset and the number of rows and columns. It also gives us the column types and a summary of the different data types contained in the data frame.\nOr we could use Glimpse to get a really quick idea of what’s in this dataset.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel~\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <fct> male, female, female, NA, female, male, female, male~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n\n\nWe can use select to specify certain columns or to exclude columns we don’t need right now. Let’s say we only need to check the species column.\n\npenguins |> \n    select(species)\n\n# A tibble: 344 x 1\n   species\n   <fct>  \n 1 Adelie \n 2 Adelie \n 3 Adelie \n 4 Adelie \n 5 Adelie \n 6 Adelie \n 7 Adelie \n 8 Adelie \n 9 Adelie \n10 Adelie \n# ... with 334 more rows\n\n\nWe can also get everything except the species columns:\n\npenguins |> \n    select(-species)\n\n# A tibble: 344 x 7\n   island    bill_length_mm bill_depth_mm flipper_length_mm body_m~1 sex    year\n   <fct>              <dbl>         <dbl>             <int>    <int> <fct> <int>\n 1 Torgersen           39.1          18.7               181     3750 male   2007\n 2 Torgersen           39.5          17.4               186     3800 fema~  2007\n 3 Torgersen           40.3          18                 195     3250 fema~  2007\n 4 Torgersen           NA            NA                  NA       NA <NA>   2007\n 5 Torgersen           36.7          19.3               193     3450 fema~  2007\n 6 Torgersen           39.3          20.6               190     3650 male   2007\n 7 Torgersen           38.9          17.8               181     3625 fema~  2007\n 8 Torgersen           39.2          19.6               195     4675 male   2007\n 9 Torgersen           34.1          18.1               193     3475 <NA>   2007\n10 Torgersen           42            20.2               190     4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable name 1: body_mass_g\n\n\n\n\n4.3.3 Change column names\nThe rename function makes it easy to change column names. Starting with the penguin data, we’ll type rename and change the name of our island column to island underscore new.\n\npenguins |> \n    rename(islands_new = island)\n\n# A tibble: 344 x 8\n   species islands_new bill_length_mm bill_depth_mm flippe~1 body_~2 sex    year\n   <fct>   <fct>                <dbl>         <dbl>    <int>   <int> <fct> <int>\n 1 Adelie  Torgersen             39.1          18.7      181    3750 male   2007\n 2 Adelie  Torgersen             39.5          17.4      186    3800 fema~  2007\n 3 Adelie  Torgersen             40.3          18        195    3250 fema~  2007\n 4 Adelie  Torgersen             NA            NA         NA      NA <NA>   2007\n 5 Adelie  Torgersen             36.7          19.3      193    3450 fema~  2007\n 6 Adelie  Torgersen             39.3          20.6      190    3650 male   2007\n 7 Adelie  Torgersen             38.9          17.8      181    3625 fema~  2007\n 8 Adelie  Torgersen             39.2          19.6      195    4675 male   2007\n 9 Adelie  Torgersen             34.1          18.1      193    3475 <NA>   2007\n10 Adelie  Torgersen             42            20.2      190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n\n\nLet’s say we want to change our columns so that they’re spelled and formatted correctly. Similar to the rename function, the rename_with() function can change column names to be more consistent. For example, maybe we want all of our column names to be in uppercase. We can use the rename_with() function to do that.\n\nrename_with(penguins, toupper)\n\n# A tibble: 344 x 8\n   SPECIES ISLAND    BILL_LENGTH_MM BILL_DEPTH_MM FLIPPER_~1 BODY_~2 SEX    YEAR\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: FLIPPER_LENGTH_MM,\n#   2: BODY_MASS_G\n\n\nThe clean names function in the Janitor package will automatically make sure that the column names are unique and consistent. This ensures that there’s only characters, numbers, and underscores in the names.\n\nclean_names(penguins)\n\n# A tibble: 344 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n\n\n\n\n4.3.4 Organizing data\nLet’s start by sorting our data.\n\n#sort data by bill length\npenguins |> \n    arrange(bill_length_mm)\n\n# A tibble: 344 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Dream               32.1          15.5        188    3050 fema~  2009\n 2 Adelie  Dream               33.1          16.1        178    2900 fema~  2008\n 3 Adelie  Torgersen           33.5          19          190    3600 fema~  2008\n 4 Adelie  Dream               34            17.1        185    3400 fema~  2008\n 5 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n 6 Adelie  Torgersen           34.4          18.4        184    3325 fema~  2007\n 7 Adelie  Biscoe              34.5          18.1        187    2900 fema~  2008\n 8 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n 9 Adelie  Torgersen           34.6          17.2        189    3200 fema~  2008\n10 Adelie  Biscoe              35            17.9        190    3450 fema~  2008\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n\n\n\n#sort data by bill length in descending order\npenguins |> \n    arrange(-bill_length_mm)\n\n# A tibble: 344 x 8\n   species   island bill_length_mm bill_depth_mm flipper_l~1 body_~2 sex    year\n   <fct>     <fct>           <dbl>         <dbl>       <int>   <int> <fct> <int>\n 1 Gentoo    Biscoe           59.6          17           230    6050 male   2007\n 2 Chinstrap Dream            58            17.8         181    3700 fema~  2007\n 3 Gentoo    Biscoe           55.9          17           228    5600 male   2009\n 4 Chinstrap Dream            55.8          19.8         207    4000 male   2009\n 5 Gentoo    Biscoe           55.1          16           230    5850 male   2009\n 6 Gentoo    Biscoe           54.3          15.7         231    5650 male   2008\n 7 Chinstrap Dream            54.2          20.8         201    4300 male   2008\n 8 Chinstrap Dream            53.5          19.9         205    4500 male   2008\n 9 Gentoo    Biscoe           53.4          15.8         219    5500 male   2009\n10 Chinstrap Dream            52.8          20           205    4550 male   2008\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n\n\nYou can also sort by data using the group by function. Group by is usually combined with other functions. For example, we might want to group by a certain column and then perform an operation on those groups. With our penguin data, we can group by island and then use the summarize function to get the mean bill length.\n\npenguins |> \n    group_by(island) |> \n    #remove rows with NAs\n    drop_na() |> \n    summarise(mean_bill_length_mm = mean(bill_length_mm))\n\n# A tibble: 3 x 2\n  island    mean_bill_length_mm\n  <fct>                   <dbl>\n1 Biscoe                   45.2\n2 Dream                    44.2\n3 Torgersen                39.0\n\n\n\npenguins |> \n    group_by(island) |> \n    #remove rows with NAs\n    drop_na() |> \n    summarise(max_bill_length_mm = max(bill_length_mm))\n\n# A tibble: 3 x 2\n  island    max_bill_length_mm\n  <fct>                  <dbl>\n1 Biscoe                  59.6\n2 Dream                   58  \n3 Torgersen               46  \n\n\nBoth group by and summarize can perform multiple tasks. For example, we could group by island and species and then summarize to calculate both the mean and max.\n\npenguins |> \n    group_by(species, island) |> \n    drop_na() |> \n    summarise(mean_bill_length_mm = mean(bill_length_mm), max_bill_length_mm = max(bill_length_mm))\n\n# A tibble: 5 x 4\n# Groups:   species [3]\n  species   island    mean_bill_length_mm max_bill_length_mm\n  <fct>     <fct>                   <dbl>              <dbl>\n1 Adelie    Biscoe                   39.0               45.6\n2 Adelie    Dream                    38.5               44.1\n3 Adelie    Torgersen                39.0               46  \n4 Chinstrap Dream                    48.8               58  \n5 Gentoo    Biscoe                   47.6               59.6\n\n\nFinally we can filter results using the filter function. Let’s say we only want data on Adelie penguins.\n\npenguins |> \n    filter(species == \"Adelie\")\n\n# A tibble: 152 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 142 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n\n\n\n\n4.3.5 Transforming data\nLet’s start by manually creating a df\n\n#define variables\nid <- c(1:10)\nname <- c(\"John Mendes\", \"Rob Stewart\", \"Rachel Abrahamson\", \"Christy Hickman\", \"Johnson Harper\", \"Candace Miller\", \"Carlson Landy\", \"Pansy Jordan\", \"Darius Berry\", \"Claudia Garcia\")\njob_title <- c(\"Professional\", \"Programmer\", \"Management\", \"Clerical\", \"Developer\", \"Programmer\", \"Management\", \"Clerical\", \"Developer\", \"Programmer\")\n\n#create df\nemployee <- data.frame(id, name, job_title)\n\n#view df\nhead(employee)\n\n  id              name    job_title\n1  1       John Mendes Professional\n2  2       Rob Stewart   Programmer\n3  3 Rachel Abrahamson   Management\n4  4   Christy Hickman     Clerical\n5  5    Johnson Harper    Developer\n6  6    Candace Miller   Programmer\n\n\nRight now, the first and last names are combined into one column. We can use the separate function to split these into separate columns.\n\n#input: the df, the column we want to split, the names of the new cols, the separator\nseparate(employee, name, into = c(\"first_name\", \"last_name\"), sep = \" \" )\n\n   id first_name  last_name    job_title\n1   1       John     Mendes Professional\n2   2        Rob    Stewart   Programmer\n3   3     Rachel Abrahamson   Management\n4   4    Christy    Hickman     Clerical\n5   5    Johnson     Harper    Developer\n6   6    Candace     Miller   Programmer\n7   7    Carlson      Landy   Management\n8   8      Pansy     Jordan     Clerical\n9   9     Darius      Berry    Developer\n10 10    Claudia     Garcia   Programmer\n\n\nThe separate function has a partner, unite. The unite function allows us to merge columns together.\n\n#input: the df, the column name, columns we want to combine, if needed a separator\nunite(employee, \"new_col\", name, job_title , sep = \", \" )\n\n   id                       new_col\n1   1     John Mendes, Professional\n2   2       Rob Stewart, Programmer\n3   3 Rachel Abrahamson, Management\n4   4     Christy Hickman, Clerical\n5   5     Johnson Harper, Developer\n6   6    Candace Miller, Programmer\n7   7     Carlson Landy, Management\n8   8        Pansy Jordan, Clerical\n9   9       Darius Berry, Developer\n10 10    Claudia Garcia, Programmer\n\n\nWe can also create new variables in our data frame using the mutate function. We worked with mutate a little bit before to clean and organize our data. But mutate can also be used to add columns with calculations.\nLet’s go back to our penguin dataset. Right now, the body mass column is measured in grams. Maybe we want to add a column with kilograms.\n\npenguins |> \n    mutate(body_mass_kg = body_mass_g/1000, flipper_length_m = flipper_length_mm/1000)\n\n# A tibble: 344 x 10\n   species island    bill_~1 bill_~2 flipp~3 body_~4 sex    year body_~5 flipp~6\n   <fct>   <fct>       <dbl>   <dbl>   <int>   <int> <fct> <int>   <dbl>   <dbl>\n 1 Adelie  Torgersen    39.1    18.7     181    3750 male   2007    3.75   0.181\n 2 Adelie  Torgersen    39.5    17.4     186    3800 fema~  2007    3.8    0.186\n 3 Adelie  Torgersen    40.3    18       195    3250 fema~  2007    3.25   0.195\n 4 Adelie  Torgersen    NA      NA        NA      NA <NA>   2007   NA     NA    \n 5 Adelie  Torgersen    36.7    19.3     193    3450 fema~  2007    3.45   0.193\n 6 Adelie  Torgersen    39.3    20.6     190    3650 male   2007    3.65   0.19 \n 7 Adelie  Torgersen    38.9    17.8     181    3625 fema~  2007    3.62   0.181\n 8 Adelie  Torgersen    39.2    19.6     195    4675 male   2007    4.68   0.195\n 9 Adelie  Torgersen    34.1    18.1     193    3475 <NA>   2007    3.48   0.193\n10 Adelie  Torgersen    42      20.2     190    4250 <NA>   2007    4.25   0.19 \n# ... with 334 more rows, and abbreviated variable names 1: bill_length_mm,\n#   2: bill_depth_mm, 3: flipper_length_mm, 4: body_mass_g, 5: body_mass_kg,\n#   6: flipper_length_m\n\n\n\n\n4.3.6 Wide to long with tidyr\nWide data has observations across several columns. Each column contains data from a different condition of the variable. In this example, different years.\nLong data has all the observations in a single column, and variables in separate columns.\nThat<80><99>s where pivot_longer() comes in. As part of the tidyr package, you can use this R function to lengthen the data in a data frame by increasing the number of rows and decreasing the number of columns. Similarly, if you want to convert your data to have more columns and fewer rows, you would use the pivot_wider() function."
  },
  {
    "objectID": "code/3_data_in_R.html#same-data-different-outcome",
    "href": "code/3_data_in_R.html#same-data-different-outcome",
    "title": "4  Data in R",
    "section": "4.4 Same data, different outcome",
    "text": "4.4 Same data, different outcome\nNow, we’ll work with a very famous data example: Anscombe’s quartet. Anscombe’s quartet has four datasets that have nearly identical summary statistics. But those summary statistics might be misleading.\n\n#install.packages(\"Tmisc\")\n\n\nlibrary(Tmisc)\ndata(quartet)\nhead(quartet)\n\n  set  x    y\n1   I 10 8.04\n2   I  8 6.95\n3   I 13 7.58\n4   I  9 8.81\n5   I 11 8.33\n6   I 14 9.96\n\n\nLet’s get a summary of each set with the mean, standard deviation, and correlation for each of these datasets.\n\nquartet |> \n    group_by(set) |> \n    summarise(mean(x), sd(x), mean(y), sd(y), cor(x,y))\n\n# A tibble: 4 x 6\n  set   `mean(x)` `sd(x)` `mean(y)` `sd(y)` `cor(x, y)`\n  <fct>     <dbl>   <dbl>     <dbl>   <dbl>       <dbl>\n1 I             9    3.32      7.50    2.03       0.816\n2 II            9    3.32      7.50    2.03       0.816\n3 III           9    3.32      7.5     2.03       0.816\n4 IV            9    3.32      7.50    2.03       0.817\n\n\nBased on the summaries we created with our statistical measures, these datasets are identical, but sometimes just looking at the summarized data can be misleading.\nLet’s put together some simple graphs to help us visualize this data and check if the datasets are actually identical. You’ll learn more about plotting data in R later. But for now, we’ll just get a quick idea of how this data appears.\n\nggplot(quartet, aes(x,y)) +\n    geom_point() +\n    geom_smooth(method = lm, se = FALSE) +\n    facet_wrap(~set)\n\n\n\n\nLet’s check out another thing, the datasauRus package. The datasauRus creates plots with the Anscombe data in different shapes.\n\n#install.packages(\"datasauRus\")\n\n\nlibrary(datasauRus)\n\n\nggplot(datasaurus_dozen, aes(x, y, colour = dataset)) +\n    geom_point() +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    facet_wrap(~dataset)"
  },
  {
    "objectID": "code/3_data_in_R.html#the-bias-function",
    "href": "code/3_data_in_R.html#the-bias-function",
    "title": "4  Data in R",
    "section": "4.5 The bias function",
    "text": "4.5 The bias function\nIn R, we can actually quantify bias by comparing the actual outcome of our data with the predicted outcome. The bias function finds the average amount that the actual outcome is greater than the predicted outcome. It’s included in the sim design package.\nIf the model is unbiased, the outcome should be pretty close to zero. A high result means that your data might be biased.\nLet’s say we’re working with a local weather channel to determine if their weather predictions are biased.\n\n#install.packages(\"SimDesign\")\n\n\nlibrary(\"SimDesign\")\n\nWe’ll use the bias function to compare forecasted temperatures with actual temperatures.\n\n#create some vectors with data\nactual_temp <- c(68.3, 70, 72.4, 71, 67, 70)\npredicted_temp <- c(67.9, 69, 71.5, 70, 67, 69)\n\n#apply the bias fct\nbias(actual_temp, predicted_temp)\n\n[1] 0.7166667\n\n\nWhen we run this we find out that the result Is 0.71. That’s pretty close to zero but the prediction seemed biased towards lower temperatures which, means they aren’t as accurate as they could be.\nIf we were seeing consistent bias in our sample, we can use the sample() function to inject a randomization element into our R programming\n\npenguins %>% \n  drop_na() %>% \n  group_by(species) %>%\n  summarise(min(bill_depth_mm))\n\n# A tibble: 3 x 2\n  species   `min(bill_depth_mm)`\n  <fct>                    <dbl>\n1 Adelie                    15.5\n2 Chinstrap                 16.4\n3 Gentoo                    13.1"
  },
  {
    "objectID": "code/4_data_vis_in_R.html",
    "href": "code/4_data_vis_in_R.html",
    "title": "5  Data visualization in R",
    "section": "",
    "text": "Some useful packages for data vis in R are:\nIn ggplot2 an aesthetic is a visual property of an object in your plot. For example, in a scatter plot aesthetics include things like the size, shape or color of your data points.\nA geom refers to the geometric object used to represent your data. For example, you can use points to create a scatter plot, bars to create a bar chart, or lines to create a line diagram.\nFacets let you display smaller groups or subsets of your data. With facets, you can create separate plots for all the variables in your dataset.\nThe label and annotate functions let you customize your plot. You can add text like titles, subtitles and captions to communicate the purpose of your plot or highlight important data.\nThe grammar of graphics in ggplot2:"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#getting-started",
    "href": "code/4_data_vis_in_R.html#getting-started",
    "title": "5  Data visualization in R",
    "section": "5.1 Getting started",
    "text": "5.1 Getting started\nFirst let’s load the data and have a look:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n\nhead(penguins)\n\n# A tibble: 6 x 8\n  species island    bill_length_mm bill_depth_mm flipper_l~1 body_~2 sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema~  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema~  2007\n4 Adelie  Torgersen           NA            NA            NA      NA <NA>   2007\n5 Adelie  Torgersen           36.7          19.3         193    3450 fema~  2007\n6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007\n# ... with abbreviated variable names 1: flipper_length_mm, 2: body_mass_g\n\n\nSuppose you want to plot the relationship between body mass and flipper length in the three penguin species. You can choose a specific geom that fits the type of data you have. Points show the relationship between two quantitative variables. A scatterplot of points would be an effective way to display the relationship between the two variables. You can put flipper length on the x-axis and body mass on the y-axis.\nFor this we need:\n\nThe ggplot() function, which creates a coordinate system that you can add layers to. The first argument of the ggplot() function is the dataset to use in the plot. In this case, it<80><99>s penguins.\nYou use a + symbol to add a new layer to your plot. You complete your plot by adding one or more layers to ggplot().\nAdd a geom function. The geom_point() function uses points to create scatterplots, the geom_bar function uses bars to create bar charts, and so on. Each geom function in ggplot2 takes a mapping argument. This defines how variables in your dataset are mapped to visual properties. The mapping argument is always paired with the aes() function. The x and y arguments of the aes() function specify which variables to map to the x-axis and the y-axis of the coordinate system. Mapping means matching up a specific variable in your dataset with a specific aesthetic. For example, you can map a variable to the x- axis of your plot, or you can map a variable to the y-axis of your plot.\n\n\nggplot(penguins) +\n    geom_point(mapping = aes(x=flipper_length_mm, y = body_mass_g))\n\n\n\n\nYou can write the same section of code above using a different syntax with the mapping argument inside the ggplot() call:\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_point()"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#exploring-aesthethics",
    "href": "code/4_data_vis_in_R.html#exploring-aesthethics",
    "title": "5  Data visualization in R",
    "section": "5.2 Exploring aesthethics",
    "text": "5.2 Exploring aesthethics\nWe can map variables, as well as color, size and shape, to aesthetics. Let’s add a third variable to our scatter plot by mapping it to a new aesthetic. We’ll map the variable species to the aesthetic color by adding some code inside the parentheses of the aes function.\nUsing more than one aesthetic can also be a way to make your visuals more accessible because it gives your viewers more than one way to make sense of your data.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point()\n\n\n\n\nWe can also use shape to highlight the different penguin species.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g, shape = species)) +\n    geom_point()\n\n\n\n\nIf we want we can map more than one aesthetic to the same variable. Let’s map both color and shape to species.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g, shape = species, color = species)) +\n    geom_point()\n\n\n\n\nLet’s add size as well and map three aesthetics to species. If we add size equal species, each colored shape will also be a different size.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g, shape = species, color = species, size = species)) +\n    geom_point()\n\n\n\n\nWe can also map species to the alpha aesthetic, which controls the transparency of the points. Alpha is a good option when you’ve got a dense plot with lots of data points.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g, alpha = species)) +\n    geom_point()\n\n\n\n\nYou can also set the aesthetic apart from a specific variable. Let’s say we want to change the color of all the points to purple. Here we don’t want to map color to a specific variable like species. We just want every point in our scatter plot to be purple. So we need to set our new piece of code outside of the aes function and use quotation marks for our color value. If we want to change the appearance of our overall plot without regard to specific variables, we write code outside of the aes function.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_point(color=\"purple\")"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#different-geom-functions",
    "href": "code/4_data_vis_in_R.html#different-geom-functions",
    "title": "5  Data visualization in R",
    "section": "5.3 Different geom functions",
    "text": "5.3 Different geom functions\n\n5.3.1 Smooting\nSmoothing enables the detection of a data trend even when you can’t easily notice a trend from the plotted data points. Ggplot2<80><99>s smoothing functionality is helpful because it adds a smoothing line as another layer to a plot; the smoothing line helps the data to make sense to a casual observer.\nTo change the type of plot, we can put geom_smooth in place of geom underscore point.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_smooth(color=\"purple\")\n\n\n\n\nInstead of points, there’s a smooth line that fits the data. The geom underscore smooth function’s useful for showing general trends in our data.\nWe can even use two geoms in the same plot. Let’s say we want to show the relationship between the trend line and the data points more clearly.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_point() +\n    geom_smooth(color=\"purple\")\n\n\n\n\nLet’s say we want to plot a separate line for each species of penguin. We can add the line type aesthetic to our code and map it to the variable species. Geom underscore smooth will draw a different line with a different line type for each species of penguin.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_smooth(aes(linetype = species))\n\n\n\n\nThere are two types of smoothing:\n\nLoess smoothing: The loess smoothing process is best for smoothing plots with less than 1000 points.\n\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_smooth(method = \"loess\")\n\n\n\n\n\nGam smoothing: Gam smoothing, or generalized additive model smoothing, is useful for smoothing plots with a large number of points.\n\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_smooth(method=\"gam\", formula = y ~s(x))\n\n\n\n\n\n\n5.3.2 Jittering\nThe geom_jitter function creates a scatter plot and then adds a small amount of random noise to each point in the plot. Jittering helps us deal with over-plotting, which happens when the data points in a plot overlap with each other. Jittering makes the points easier to find.\n\nggplot(penguins, aes(x=flipper_length_mm, y = body_mass_g)) +\n    geom_jitter()\n\n\n\n\n\n\n5.3.3 Barcharts\nFor this, lets work with the diamond dataset that is already part of the ggplot package.\n\nggplot(diamonds, aes(x=cut)) +\n    geom_bar()\n\n\n\n\nNotice that we didn’t supply a variable for the y-axis. When you use geom_bar, R automatically counts how many times each x-value appears in the data, and then shows the counts on the y-axis. The default for geom_bar is to count rows.\n\nggplot(diamonds, aes(x=cut)) +\n    geom_bar()\n\n\n\n\nGeom underscore bar uses several aesthetics that you’re already familiar with, such as color, size, and alpha. Let’s add the color aesthetic to our plot and map it to the variable cut. We write the code the same way as we did with scatter plots and add color equals cut after x equals cut. The color aesthetic adds color to the outline of each bar.\n\nggplot(diamonds, aes(x=cut, color = cut)) +\n    geom_bar()\n\n\n\n\nWe can use the fill aesthetic to add color to the inside of each bar. In our code, we put fill equals cut in place of color equals cut.\n\nggplot(diamonds, aes(x=cut, fill = cut)) +\n    geom_bar()\n\n\n\n\nIf we map fill to a new variable, geom underscore bar will display what’s called a stacked bar chart. Let’s map fill to clarity instead of cut.\n\nggplot(diamonds, aes(x=cut, fill = clarity)) +\n    geom_bar()"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#aesthetics-and-facets",
    "href": "code/4_data_vis_in_R.html#aesthetics-and-facets",
    "title": "5  Data visualization in R",
    "section": "5.4 Aesthetics and facets",
    "text": "5.4 Aesthetics and facets\nFacet functions let you display smaller groups or subsets of your data. A facet is a side or section of an object, like the sides of a gemstone. Facets show different sides of your data by placing each subset on its own plot.\nFacet functions in ggplot2:\n\nFacet_wrap(): To facet your plot by a single variable, use facet underscore wrap\nFacet_grid(): facet your plot with two variables. facet_grid will include plots even if they are empty\n\n\n5.4.1 Facet_wrap\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    facet_wrap(~species)\n\n\n\n\nLet’s try faceting the diamonds dataset. Earlier, we made a bar chart that showed the number of diamonds for each category of cut. Fair, good, very good, premium, and ideal. We can use facet underscore wrap on the cut variable to create a separate plot for each category of cut.\n\nggplot(diamonds, aes(x = color, fill = cut)) +\n    geom_bar() +\n    facet_wrap(~cut)\n\n\n\n\n\n\n5.4.2 Facet_grid\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    facet_grid(sex~species)\n\n\n\n\nIf we want, we can focus our plot on only one of the two variables. For example, we can tell R to remove sex from the vertical dimension of the plot and just show species.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    facet_grid(~sex)"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#filtering-and-plots",
    "href": "code/4_data_vis_in_R.html#filtering-and-plots",
    "title": "5  Data visualization in R",
    "section": "5.5 Filtering and plots",
    "text": "5.5 Filtering and plots\nFiltering your data before you plot it allows you to focus on specific subsets of your data and gain more targeted insights. To do this, just include the dplyr filter() function in your ggplot syntax.\n\npenguins |>\n    filter(species == \"Adelie\") |> \n    ggplot(aes(x = bill_length_mm, y = flipper_length_mm, colour = species)) + \n    geom_point(alpha = 0.3,  position = position_jitter()) + \n    stat_smooth(method = \"lm\")\n\n\n\n\nWe can also filter using several categories:\n\npenguins |>\n    filter(species == \"Adelie\") |> \n    filter(sex == \"female\") |> \n    ggplot(aes(x = bill_length_mm, y = flipper_length_mm, colour = species)) + \n    geom_point(alpha = 0.3,  position = position_jitter()) + \n    stat_smooth(method = \"lm\")"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#conditional-coloring",
    "href": "code/4_data_vis_in_R.html#conditional-coloring",
    "title": "5  Data visualization in R",
    "section": "5.6 Conditional coloring",
    "text": "5.6 Conditional coloring\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n    geom_point(aes(color = ifelse(flipper_length_mm > 200, \"red\", \"grey\")))"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#annotation-layer",
    "href": "code/4_data_vis_in_R.html#annotation-layer",
    "title": "5  Data visualization in R",
    "section": "5.7 Annotation layer",
    "text": "5.7 Annotation layer\n\n5.7.1 Titles, subtiles and labels\nTo annotate means to add notes to a document or diagram to explain or comment upon it.\nThe label function is useful for adding informative labels to a plot such as titles, subtitles, and captions. For example, we can add a title to our plot that shows the relationship between body mass and flipper length for the three penguin species.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\")\n\n\n\n\nWe can also add a subtitle to our plot to highlight important information about our data.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = \"Sample of three penguin species\")\n\n\n\n\nWe can add a caption to our plot in the same way. Captions let us show the source of our data.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = \"Sample of three penguin species\",\n         caption = \"Data collected by Dr. Kirsten Gorman\")\n\n\n\n\nWe can also combine this with some variables, i.e. the min and max values.\n\nmin_length <- min(penguins$flipper_length_mm, na.rm = TRUE)\nmax_length <- max(penguins$flipper_length_mm, na.rm = TRUE)\n\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = paste0(\"Min length: \", min_length, \" and max length: \", max_length))\n\n\n\n\nNow you want to clean up the x and y axis labels to make sure they are really clear.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = paste0(\"Min length: \", min_length, \" and max length: \", max_length),\n         x = \"Flipper length (mm)\",\n         y = \"Body mass (g)\")\n\n\n\n\n\n\n5.7.2 Labelling data points inside the grid\nIf we want to put text inside the grid to call out specific data points, we can use the annotate function. For example, let’s say we want to highlight the data from the Gentoo penguins.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = \"Sample of three penguin species\",\n         caption = \"Data collected by Dr. Kirsten Gorman\") +\n    #annotate has information on: the type of label, the location of the label and the context of the label\n    annotate(\"text\", x = 220, y = 3500, label = \"Gentoos are the largest\")\n\n\n\n\nWe can customize our annotation even more. Let’s say we want to change the color of our text.\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = \"Sample of three penguin species\",\n         caption = \"Data collected by Dr. Kirsten Gorman\") +\n    #annotate has information on: the type of label, the location of the label and the context of the label\n    annotate(\"text\", x = 220, y = 3500, label = \"Gentoos are the largest\", color = \"purple\", fontface=\"bold\", size=4.5, angle = 25)\n\n\n\n\nBy this point, our code is getting pretty long. If you want to use less code, you can store your plot as a variable in R.\n\np <-\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() +\n    labs(title=\"Palmer Penguins: Body mass versus flipper length\",\n         subtitle = \"Sample of three penguin species\",\n         caption = \"Data collected by Dr. Kirsten Gorman\")\n\nNow, instead of writing all the code again, we can just call p and add an annotation to it like this.\n\np + annotate(\"text\", x = 220, y = 3500, label = \"Gentoos are the largest\")"
  },
  {
    "objectID": "code/4_data_vis_in_R.html#saving-your-visualizations",
    "href": "code/4_data_vis_in_R.html#saving-your-visualizations",
    "title": "5  Data visualization in R",
    "section": "5.8 Saving your visualizations",
    "text": "5.8 Saving your visualizations\nTo save our plots, we can use the Export option in the plots tab of RStudio or the ggsave function provided by the ggplot2 package.\n\n5.8.1 Export\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n    geom_point() \n\n\n\n\nLet’s use the Export option in the plots tab to save our plot. We can save it as an image file or a PDF file.\n\n\n5.8.2 Ggsave\nGgsave is a useful function for saving a plot. It defaults to saving the last plot that you displayed and uses the size of the current graphics device. Let’s try saving our plot as a PNG file using ggsave.\n\nggsave(\"../output/Three_penguin_species.png\")\n\n\n\n5.8.3 Using a graphics device\nIn most cases, ggsave() is the simplest way to save your plot. But there are situations when it might be best to save your plot by writing it directly to a graphics device.\nA graphics device allows a plot to appear on your computer. Examples include:\n\nA window on your computer (screen device)\nA PDF, PNG, or JPEG file (file device)\nAn SVG, or scalable vector graphics file (file device)\n\nExample of using png():\n\npng(file = \"../output/png_example.png\", bg = \"transparent\")\nplot(1:10)\nrect(1, 5, 3, 7, col = \"white\")\n\ndev.off()\n\nquartz_off_screen \n                2 \n\n\nExample of using pdf():\n\npdf(file = \"../output/pdf_example.pdf\",    \n       width = 4,     \n       height = 4) \n\nplot(x = 1:10, y = 1:10)\nabline(v = 0)\ntext(x = 0, y = 1, labels = \"Random text\")\n\ndev.off()\n\nquartz_off_screen \n                2"
  },
  {
    "objectID": "code/5_documenting_in_R.html",
    "href": "code/5_documenting_in_R.html",
    "title": "6  Documentation and reports",
    "section": "",
    "text": "Markdown lets you create a record of your analysis and conclusions in a document. It ties together your code and your report so you can share every step of your analysis.\nR Markdown documents are written in Markdown. Markdown is a syntax for formatting plain text files. Using Markdown makes it easier to write and format text in your document.\nMarkdown is also easy to read and to learn. For example, if you want to italicize a word or phrase in Markdown, just add a single underscore or asterisk right before and after the word. When you create a report of the document, the Markdown formatting is no longer visible, just the word or phrase in italics.\nR Markdown lets you convert your files into lots of different formats too. You can create HTML, PDF, and Word documents, or you can convert to a slide presentation or dashboard.\nCode added to an RMD file is usually called a code chunk.\nSome popular packages with templates for R Markdown include the following:\n\nThe vitae package contains templates for creating and maintaining a résumé or curriculum vitae (CV)\nThe rticles package provides templates for various journals and publishers\nThe learnr package makes it easy to turn any R Markdown document into an interactive tutorial\nThe bookdown package facilitates writing books and long-form articles\nThe flexdashboard package lets you publish a group of related data visualizations as a dashboard"
  }
]