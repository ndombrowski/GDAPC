{
  "hash": "71723e48cd5b5e36e7bee98193434720",
  "result": {
    "markdown": "# Data in R\n\n## R data frames\n\nA **data frame** is a collection of columns. Some rules:\n- columns should be named\n- data stored in your data frame can be many different types, like numeric, factor, or character\n- each column should contain the same number of data items, even if some of those data items are missing\n\n**Tibbles** are like streamlined data frames. They make working with data easier, but they're a little different from standard data frames:\n- tibbles never change the data types of the inputs. They won't change your strings to factors or anything else\n- You can make more changes to base data frames, but tibbles are easier to use. This saves time because you won't have to do as much cleaning or changing data types in tibbles. \n- Tibbles also never change the names of your variables, and they never create row names\n- tibbles make printing in R easier. They won't accidentally overload your console because they're automatically set to pull up only the first 10 rows and as many columns as fit on screen\n\nTidy data standards:\n\n- Variables are organized into columns\n- Observations are organized into rows\n- Each value must have its own cell\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load libs\nlibrary(\"tidyverse\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#load data\ndata(\"diamonds\")\n\n#view the first six rows\nhead(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#get the structure\nstr(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print column names\ncolnames(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"carat\"   \"cut\"     \"color\"   \"clarity\" \"depth\"   \"table\"   \"price\"  \n [8] \"x\"       \"y\"       \"z\"      \n```\n:::\n:::\n\n\n\nNext, lets use the mutate function to make changes to our data frame. The mutate function is part of the dplyr package which is in the tidyverse. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#add a new column\ndf <- mutate(diamonds, carat_2 = carat * 100)\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 11\n  carat cut       color clarity depth table price     x     y     z carat_2\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>   <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43      23\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31      21\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31      23\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63      29\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75      31\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48      24\n```\n:::\n:::\n\n\n\n### Creating dfs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create some vectors\nnames <- c(\"Julia\", \"Peter\", \"Leo\", \"Sara\")\nage <- c(21,14, 17,50 )\n\n#create and view df\npeople <- data.frame(names, age)\npeople\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  names age\n1 Julia  21\n2 Peter  14\n3   Leo  17\n4  Sara  50\n```\n:::\n:::\n\n\n\nNow that you have a data frame, you can work with it using all of the tools in `R`. For example, you could use `mutate()` if you wanted to create a new variable that would capture each person's age in twenty years. The code chunk below creates that new variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(people, age_in_20 = age + 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  names age age_in_20\n1 Julia  21        41\n2 Peter  14        34\n3   Leo  17        37\n4  Sara  50        70\n```\n:::\n:::\n\n\n\n\n### Creating tibbles\n\nWe can easily create tibbles from data sets as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(as_tibble(diamonds))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n```\n:::\n:::\n\n\n\n## Data import\n\n### The data() function\n\nThe default installation of R comes with a number of preloaded datasets that you can practice with. You can use the `data()` function to load these datasets in R. If you run the data function without an argument, R will display a list of the available datasets. If you want to load a specific dataset, just enter its name in the parentheses of the data() function, i.e. `data(mtcars)`.\n\n\n### readr\n\nThe goal of readr is to provide a fast and friendly way to read rectangular data. readr supports several read_ functions. Each function refers to a specific file format.\n\n- `read_csv()`: comma separated (CSV) files\n- `read_tsv()`: tab separated files\n- `read_delim()`: general delimited files\n- `read_fwf()`: fixed width files\n- `read_table()`: tabular files where columns are separated by white-space\n- `read_log()`: web log files\n\nThe readr package comes with some sample files from built-in datasets that you can use for example code. To list the sample files, you can run the `readr_example()` function with no arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr_example()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"challenge.csv\"               \"chickens.csv\"               \n [3] \"epa78.txt\"                   \"example.log\"                \n [5] \"fwf-sample.txt\"              \"massey-rating.txt\"          \n [7] \"mini-gapminder-africa.csv\"   \"mini-gapminder-americas.csv\"\n [9] \"mini-gapminder-asia.csv\"     \"mini-gapminder-europe.csv\"  \n[11] \"mini-gapminder-oceania.csv\"  \"mtcars.csv\"                 \n[13] \"mtcars.csv.bz2\"              \"mtcars.csv.zip\"             \n[15] \"whitespace-sample.txt\"      \n```\n:::\n:::\n\n\n\nLet's try to read in a table:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(readr_example(\"mtcars.csv\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ... with 22 more rows\n```\n:::\n:::\n\n\n\n\n### readxl\n\nTo import spreadsheet data into R, you can use the readxl package. The readxl package is part of the tidyverse but is not a core tidyverse package, so you need to load readxl in R by using the library()\nfunction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n```\n:::\n\n\n\nLets check out example files first:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadxl_example()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"clippy.xls\"    \"clippy.xlsx\"   \"datasets.xls\"  \"datasets.xlsx\"\n [5] \"deaths.xls\"    \"deaths.xlsx\"   \"geometry.xls\"  \"geometry.xlsx\"\n [9] \"type-me.xls\"   \"type-me.xlsx\" \n```\n:::\n:::\n\n\n\nNow, lets read in one of those examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_excel(readxl_example(\"type-me.xlsx\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 2\n   `maybe boolean?` description                         \n   <chr>            <chr>                               \n 1 <NA>             \"empty\"                             \n 2 0                \"0 (numeric)\"                       \n 3 1                \"1 (numeric)\"                       \n 4 40908            \"datetime\"                          \n 5 TRUE             \"boolean true\"                      \n 6 FALSE            \"boolean false\"                     \n 7 cabbage          \"\\\"cabbage\\\"\"                       \n 8 true             \"the string \\\"true\\\"\"               \n 9 F                \"the letter \\\"F\\\"\"                  \n10 False            \"\\\"False\\\" preceded by single quote\"\n```\n:::\n:::\n\n\n\nYou can use the excel_sheets() function to list the names of the individual sheets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexcel_sheets(readxl_example(\"type-me.xlsx\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical_coercion\" \"numeric_coercion\" \"date_coercion\"    \"text_coercion\"   \n```\n:::\n:::\n\n\n\nYou can also specify a sheet by name or number.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_excel(readxl_example(\"type-me.xlsx\"), sheet = \"numeric_coercion\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 2\n  `maybe numeric?` explanation            \n  <chr>            <chr>                  \n1 <NA>             \"empty\"                \n2 TRUE             \"boolean true\"         \n3 FALSE            \"boolean false\"        \n4 40534            \"datetime\"             \n5 123456           \"the string \\\"123456\\\"\"\n6 123456           \"the number 123456\"    \n7 cabbage          \"\\\"cabbage\\\"\"          \n```\n:::\n:::\n\n\n\n### Practice\n\nRead in a dataset\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbookings_df <- read_csv(\"../data/hotel_bookings.csv\")\nhead(bookings_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 32\n  hotel   is_ca~1 lead_~2 arriv~3 arriv~4 arriv~5 arriv~6 stays~7 stays~8 adults\n  <chr>     <dbl>   <dbl>   <dbl> <chr>     <dbl>   <dbl>   <dbl>   <dbl>  <dbl>\n1 Resort~       0     342    2015 July         27       1       0       0      2\n2 Resort~       0     737    2015 July         27       1       0       0      2\n3 Resort~       0       7    2015 July         27       1       0       1      1\n4 Resort~       0      13    2015 July         27       1       0       1      1\n5 Resort~       0      14    2015 July         27       1       0       2      2\n6 Resort~       0      14    2015 July         27       1       0       2      2\n# ... with 22 more variables: children <dbl>, babies <dbl>, meal <chr>,\n#   country <chr>, market_segment <chr>, distribution_channel <chr>,\n#   is_repeated_guest <dbl>, previous_cancellations <dbl>,\n#   previous_bookings_not_canceled <dbl>, reserved_room_type <chr>,\n#   assigned_room_type <chr>, booking_changes <dbl>, deposit_type <chr>,\n#   agent <chr>, company <chr>, days_in_waiting_list <dbl>,\n#   customer_type <chr>, adr <dbl>, required_car_parking_spaces <dbl>, ...\n```\n:::\n:::\n\n\n\nIf you want to create another data frame using `bookings_df` that focuses on the average daily rate, which is referred to as `adr` in the data frame, and  `adults`, you can use the following code chunk to do that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_df <- select(bookings_df, adr, adults)\nhead(new_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n    adr adults\n  <dbl>  <dbl>\n1     0      2\n2     0      2\n3    75      1\n4    75      1\n5    98      2\n6    98      2\n```\n:::\n:::\n\n\nTo create new variables in your data frame, you can use the `mutate()` function. This will make changes to the data frame, but not to the original data set you imported. That source data will remain unchanged. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(new_df, total = adr/adults)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 119,390 x 3\n     adr adults total\n   <dbl>  <dbl> <dbl>\n 1    0       2   0  \n 2    0       2   0  \n 3   75       1  75  \n 4   75       1  75  \n 5   98       2  49  \n 6   98       2  49  \n 7  107       2  53.5\n 8  103       2  51.5\n 9   82       2  41  \n10  106.      2  52.8\n# ... with 119,380 more rows\n```\n:::\n:::\n\n\n\n\n## Cleaning data\n\n### Naming conventions\n\n**Do's**\n\n- Keep your filenames to a reasonable length\n- Use underscores and hyphens for readability\n- Start or end your filename with a letter or number\n- Use a standard date format when applicable; example: YYYY-MM-DD\n- Use filenames for related files that work well with default ordering; example: in chronological order, or logical order using numbers first\n\n\n**Don't**\n\n- Use unnecessary additional characters in filenames\n- Use spaces or <e2><80><9c>illegal<e2><80><9d> characters; examples: &, %, #, <, or >\n- Start or end your filename with a symbol\n- Use incomplete or inconsistent date formats; example: M-D-YY\n- Use filenames for related files that do not work well with default ordering; examples: a random system of numbers or date formats, or using letters first\n\n\n### Data exploration\n\nSome useful packages:\n\n- The **Here** package makes referencing files easier\n- The **Skimr** package makes summarizing data really easy and let's you skim through it more quickly\n- The **Janitor** package has functions for cleaning data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load libs\nlibrary(palmerpenguins)\nlibrary(here)\nlibrary(skimr)\nlibrary(janitor)\n```\n:::\n\n\n\n\nSome useful functions are:\n\n- `skim_without_charts()`\n- `glimpse()`\n- `select()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#summarize data \nskim_without_charts(penguins)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |         |\n|:------------------------|:--------|\n|Name                     |penguins |\n|Number of rows           |344      |\n|Number of columns        |8        |\n|_______________________  |         |\n|Column type frequency:   |         |\n|factor                   |3        |\n|numeric                  |5        |\n|________________________ |         |\n|Group variables          |None     |\n\n\n**Variable type: factor**\n\n|skim_variable | n_missing| complete_rate|ordered | n_unique|top_counts                  |\n|:-------------|---------:|-------------:|:-------|--------:|:---------------------------|\n|species       |         0|          1.00|FALSE   |        3|Ade: 152, Gen: 124, Chi: 68 |\n|island        |         0|          1.00|FALSE   |        3|Bis: 168, Dre: 124, Tor: 52 |\n|sex           |        11|          0.97|FALSE   |        2|mal: 168, fem: 165          |\n\n\n**Variable type: numeric**\n\n|skim_variable     | n_missing| complete_rate|    mean|     sd|     p0|     p25|     p50|    p75|   p100|\n|:-----------------|---------:|-------------:|-------:|------:|------:|-------:|-------:|------:|------:|\n|bill_length_mm    |         2|          0.99|   43.92|   5.46|   32.1|   39.23|   44.45|   48.5|   59.6|\n|bill_depth_mm     |         2|          0.99|   17.15|   1.97|   13.1|   15.60|   17.30|   18.7|   21.5|\n|flipper_length_mm |         2|          0.99|  200.92|  14.06|  172.0|  190.00|  197.00|  213.0|  231.0|\n|body_mass_g       |         2|          0.99| 4201.75| 801.95| 2700.0| 3550.00| 4050.00| 4750.0| 6300.0|\n|year              |         0|          1.00| 2008.03|   0.82| 2007.0| 2007.00| 2008.00| 2009.0| 2009.0|\n:::\n:::\n\n\nFirst, it gives us a summary with the name of the dataset and the number of rows and columns. It also gives us the column types and a summary of the different data types contained in the data frame.\n\nOr we could use Glimpse to get a really quick idea of what's in this dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel~\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse~\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, ~\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, ~\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186~\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, ~\n$ sex               <fct> male, female, female, NA, female, male, female, male~\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007~\n```\n:::\n:::\n\n\nWe can use select to specify certain columns or to exclude columns we don't need right now. Let's say we only need to check the species column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    select(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 1\n   species\n   <fct>  \n 1 Adelie \n 2 Adelie \n 3 Adelie \n 4 Adelie \n 5 Adelie \n 6 Adelie \n 7 Adelie \n 8 Adelie \n 9 Adelie \n10 Adelie \n# ... with 334 more rows\n```\n:::\n:::\n\n\nWe can also get everything except the species columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    select(-species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 7\n   island    bill_length_mm bill_depth_mm flipper_length_mm body_m~1 sex    year\n   <fct>              <dbl>         <dbl>             <int>    <int> <fct> <int>\n 1 Torgersen           39.1          18.7               181     3750 male   2007\n 2 Torgersen           39.5          17.4               186     3800 fema~  2007\n 3 Torgersen           40.3          18                 195     3250 fema~  2007\n 4 Torgersen           NA            NA                  NA       NA <NA>   2007\n 5 Torgersen           36.7          19.3               193     3450 fema~  2007\n 6 Torgersen           39.3          20.6               190     3650 male   2007\n 7 Torgersen           38.9          17.8               181     3625 fema~  2007\n 8 Torgersen           39.2          19.6               195     4675 male   2007\n 9 Torgersen           34.1          18.1               193     3475 <NA>   2007\n10 Torgersen           42            20.2               190     4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable name 1: body_mass_g\n```\n:::\n:::\n\n\n\n### Change column names\n\nThe rename function makes it easy to change column names. Starting with the penguin data, we'll type rename and change the name of our island column to island underscore new.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    rename(islands_new = island)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   species islands_new bill_length_mm bill_depth_mm flippe~1 body_~2 sex    year\n   <fct>   <fct>                <dbl>         <dbl>    <int>   <int> <fct> <int>\n 1 Adelie  Torgersen             39.1          18.7      181    3750 male   2007\n 2 Adelie  Torgersen             39.5          17.4      186    3800 fema~  2007\n 3 Adelie  Torgersen             40.3          18        195    3250 fema~  2007\n 4 Adelie  Torgersen             NA            NA         NA      NA <NA>   2007\n 5 Adelie  Torgersen             36.7          19.3      193    3450 fema~  2007\n 6 Adelie  Torgersen             39.3          20.6      190    3650 male   2007\n 7 Adelie  Torgersen             38.9          17.8      181    3625 fema~  2007\n 8 Adelie  Torgersen             39.2          19.6      195    4675 male   2007\n 9 Adelie  Torgersen             34.1          18.1      193    3475 <NA>   2007\n10 Adelie  Torgersen             42            20.2      190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n\n \nLet's say we want to change our columns so that they're spelled and formatted correctly. Similar to the rename function, the rename_with() function can change column names to be more consistent. For example, maybe we want all of our column names to be in uppercase. We can use the rename_with() function to do that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename_with(penguins, toupper)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   SPECIES ISLAND    BILL_LENGTH_MM BILL_DEPTH_MM FLIPPER_~1 BODY_~2 SEX    YEAR\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: FLIPPER_LENGTH_MM,\n#   2: BODY_MASS_G\n```\n:::\n:::\n\n\n\nThe clean names function in the Janitor package will automatically make sure that the column names are unique and consistent. This ensures that there's only characters, numbers, and underscores in the names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_names(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n\n\n### Organizing data\n\nLet's start by sorting our data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#sort data by bill length\npenguins |> \n    arrange(bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Dream               32.1          15.5        188    3050 fema~  2009\n 2 Adelie  Dream               33.1          16.1        178    2900 fema~  2008\n 3 Adelie  Torgersen           33.5          19          190    3600 fema~  2008\n 4 Adelie  Dream               34            17.1        185    3400 fema~  2008\n 5 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n 6 Adelie  Torgersen           34.4          18.4        184    3325 fema~  2007\n 7 Adelie  Biscoe              34.5          18.1        187    2900 fema~  2008\n 8 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n 9 Adelie  Torgersen           34.6          17.2        189    3200 fema~  2008\n10 Adelie  Biscoe              35            17.9        190    3450 fema~  2008\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#sort data by bill length in descending order\npenguins |> \n    arrange(-bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   species   island bill_length_mm bill_depth_mm flipper_l~1 body_~2 sex    year\n   <fct>     <fct>           <dbl>         <dbl>       <int>   <int> <fct> <int>\n 1 Gentoo    Biscoe           59.6          17           230    6050 male   2007\n 2 Chinstrap Dream            58            17.8         181    3700 fema~  2007\n 3 Gentoo    Biscoe           55.9          17           228    5600 male   2009\n 4 Chinstrap Dream            55.8          19.8         207    4000 male   2009\n 5 Gentoo    Biscoe           55.1          16           230    5850 male   2009\n 6 Gentoo    Biscoe           54.3          15.7         231    5650 male   2008\n 7 Chinstrap Dream            54.2          20.8         201    4300 male   2008\n 8 Chinstrap Dream            53.5          19.9         205    4500 male   2008\n 9 Gentoo    Biscoe           53.4          15.8         219    5500 male   2009\n10 Chinstrap Dream            52.8          20           205    4550 male   2008\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n\n\nYou can also sort by data using the group by function. Group by is usually combined with other functions. For example, we might want to group by a certain column and then perform an operation on those groups. With our penguin data, we can group by island and then use the summarize function to get the mean bill length.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    group_by(island) |> \n    #remove rows with NAs\n    drop_na() |> \n    summarise(mean_bill_length_mm = mean(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  island    mean_bill_length_mm\n  <fct>                   <dbl>\n1 Biscoe                   45.2\n2 Dream                    44.2\n3 Torgersen                39.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    group_by(island) |> \n    #remove rows with NAs\n    drop_na() |> \n    summarise(max_bill_length_mm = max(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  island    max_bill_length_mm\n  <fct>                  <dbl>\n1 Biscoe                  59.6\n2 Dream                   58  \n3 Torgersen               46  \n```\n:::\n:::\n\n\n\nBoth group by and summarize can perform multiple tasks. For example, we could group by island and species and then summarize to calculate both the mean and max. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    group_by(species, island) |> \n    drop_na() |> \n    summarise(mean_bill_length_mm = mean(bill_length_mm), max_bill_length_mm = max(bill_length_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 4\n# Groups:   species [3]\n  species   island    mean_bill_length_mm max_bill_length_mm\n  <fct>     <fct>                   <dbl>              <dbl>\n1 Adelie    Biscoe                   39.0               45.6\n2 Adelie    Dream                    38.5               44.1\n3 Adelie    Torgersen                39.0               46  \n4 Chinstrap Dream                    48.8               58  \n5 Gentoo    Biscoe                   47.6               59.6\n```\n:::\n:::\n\n\n\nFinally we can filter results using the filter function. Let's say we only want data on Adelie penguins. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    filter(species == \"Adelie\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 142 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n\n\n\n### Transforming data\n\nLet's start by manually creating a df\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define variables\nid <- c(1:10)\nname <- c(\"John Mendes\", \"Rob Stewart\", \"Rachel Abrahamson\", \"Christy Hickman\", \"Johnson Harper\", \"Candace Miller\", \"Carlson Landy\", \"Pansy Jordan\", \"Darius Berry\", \"Claudia Garcia\")\njob_title <- c(\"Professional\", \"Programmer\", \"Management\", \"Clerical\", \"Developer\", \"Programmer\", \"Management\", \"Clerical\", \"Developer\", \"Programmer\")\n\n#create df\nemployee <- data.frame(id, name, job_title)\n\n#view df\nhead(employee)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id              name    job_title\n1  1       John Mendes Professional\n2  2       Rob Stewart   Programmer\n3  3 Rachel Abrahamson   Management\n4  4   Christy Hickman     Clerical\n5  5    Johnson Harper    Developer\n6  6    Candace Miller   Programmer\n```\n:::\n:::\n\n\n\nRight now, the first and last names are combined into one column. We can use the separate function to split these into separate columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#input: the df, the column we want to split, the names of the new cols, the separator\nseparate(employee, name, into = c(\"first_name\", \"last_name\"), sep = \" \" )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   id first_name  last_name    job_title\n1   1       John     Mendes Professional\n2   2        Rob    Stewart   Programmer\n3   3     Rachel Abrahamson   Management\n4   4    Christy    Hickman     Clerical\n5   5    Johnson     Harper    Developer\n6   6    Candace     Miller   Programmer\n7   7    Carlson      Landy   Management\n8   8      Pansy     Jordan     Clerical\n9   9     Darius      Berry    Developer\n10 10    Claudia     Garcia   Programmer\n```\n:::\n:::\n\n\n\nThe separate function has a partner, unite. The unite function allows us to merge columns together.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#input: the df, the column name, columns we want to combine, if needed a separator\nunite(employee, \"new_col\", name, job_title , sep = \", \" )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   id                       new_col\n1   1     John Mendes, Professional\n2   2       Rob Stewart, Programmer\n3   3 Rachel Abrahamson, Management\n4   4     Christy Hickman, Clerical\n5   5     Johnson Harper, Developer\n6   6    Candace Miller, Programmer\n7   7     Carlson Landy, Management\n8   8        Pansy Jordan, Clerical\n9   9       Darius Berry, Developer\n10 10    Claudia Garcia, Programmer\n```\n:::\n:::\n\n\n\nWe can also create new variables in our data frame using the mutate function. We worked with mutate a little bit before to clean and organize our data. But mutate can also be used to add columns with calculations.\n\nLet's go back to our penguin dataset. Right now, the body mass column is measured in grams. Maybe we want to add a column with kilograms.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n    mutate(body_mass_kg = body_mass_g/1000, flipper_length_m = flipper_length_mm/1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 10\n   species island    bill_~1 bill_~2 flipp~3 body_~4 sex    year body_~5 flipp~6\n   <fct>   <fct>       <dbl>   <dbl>   <int>   <int> <fct> <int>   <dbl>   <dbl>\n 1 Adelie  Torgersen    39.1    18.7     181    3750 male   2007    3.75   0.181\n 2 Adelie  Torgersen    39.5    17.4     186    3800 fema~  2007    3.8    0.186\n 3 Adelie  Torgersen    40.3    18       195    3250 fema~  2007    3.25   0.195\n 4 Adelie  Torgersen    NA      NA        NA      NA <NA>   2007   NA     NA    \n 5 Adelie  Torgersen    36.7    19.3     193    3450 fema~  2007    3.45   0.193\n 6 Adelie  Torgersen    39.3    20.6     190    3650 male   2007    3.65   0.19 \n 7 Adelie  Torgersen    38.9    17.8     181    3625 fema~  2007    3.62   0.181\n 8 Adelie  Torgersen    39.2    19.6     195    4675 male   2007    4.68   0.195\n 9 Adelie  Torgersen    34.1    18.1     193    3475 <NA>   2007    3.48   0.193\n10 Adelie  Torgersen    42      20.2     190    4250 <NA>   2007    4.25   0.19 \n# ... with 334 more rows, and abbreviated variable names 1: bill_length_mm,\n#   2: bill_depth_mm, 3: flipper_length_mm, 4: body_mass_g, 5: body_mass_kg,\n#   6: flipper_length_m\n```\n:::\n:::\n\n\n\n\n### Wide to long with tidyr\n\n**Wide data** has observations across several columns. Each column contains data from a different condition of the variable. In this example, different years. \n\n**Long data** has all the observations in a single column, and variables in separate columns. \n\nThat<e2><80><99>s where `pivot_longer()` comes in. As part of the tidyr package, you can use this R function to lengthen the data in a data frame by increasing the number of rows and decreasing the number of columns. Similarly, if you want to convert your data to have more columns and fewer rows, you would use the `pivot_wider()` function.\n\n\n\n\n## Same data, different outcome\n\nNow, we'll work with a very famous data example: Anscombe's quartet. Anscombe's quartet has four datasets that have nearly identical summary statistics. But those summary statistics might be misleading.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"Tmisc\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Tmisc)\ndata(quartet)\nhead(quartet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  set  x    y\n1   I 10 8.04\n2   I  8 6.95\n3   I 13 7.58\n4   I  9 8.81\n5   I 11 8.33\n6   I 14 9.96\n```\n:::\n:::\n\n\n\nLet's get a summary of each set with the mean, standard deviation, and correlation for each of these datasets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquartet |> \n    group_by(set) |> \n    summarise(mean(x), sd(x), mean(y), sd(y), cor(x,y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 6\n  set   `mean(x)` `sd(x)` `mean(y)` `sd(y)` `cor(x, y)`\n  <fct>     <dbl>   <dbl>     <dbl>   <dbl>       <dbl>\n1 I             9    3.32      7.50    2.03       0.816\n2 II            9    3.32      7.50    2.03       0.816\n3 III           9    3.32      7.5     2.03       0.816\n4 IV            9    3.32      7.50    2.03       0.817\n```\n:::\n:::\n\n\n\nBased on the summaries we created with our statistical measures, these datasets are identical, but sometimes just looking at the summarized data can be misleading.\n\nLet's put together some simple graphs to help us visualize this data and check if the datasets are actually identical. You'll learn more about plotting data in R later. But for now, we'll just get a quick idea of how this data appears.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(quartet, aes(x,y)) +\n    geom_point() +\n    geom_smooth(method = lm, se = FALSE) +\n    facet_wrap(~set)\n```\n\n::: {.cell-output-display}\n![](3_data_in_R_files/figure-pdf/unnamed-chunk-40-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLet's check out another thing, the datasauRus package. The datasauRus creates plots with the Anscombe data in different shapes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"datasauRus\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(datasauRus)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datasaurus_dozen, aes(x, y, colour = dataset)) +\n    geom_point() +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    facet_wrap(~dataset)\n```\n\n::: {.cell-output-display}\n![](3_data_in_R_files/figure-pdf/unnamed-chunk-43-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## The bias function\n\nIn R, we can actually quantify bias by comparing the actual outcome of our data with the predicted outcome. The bias function finds the average amount that the actual outcome is greater than the predicted outcome. It's included in the sim design package. \n\nIf the model is unbiased, the outcome should be pretty close to zero. A high result means that your data might be biased. \n\nLet's say we're working with a local weather channel to determine if their weather predictions are biased.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"SimDesign\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"SimDesign\")\n```\n:::\n\n\n\nWe'll use the bias function to compare forecasted temperatures with actual temperatures.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create some vectors with data\nactual_temp <- c(68.3, 70, 72.4, 71, 67, 70)\npredicted_temp <- c(67.9, 69, 71.5, 70, 67, 69)\n\n#apply the bias fct\nbias(actual_temp, predicted_temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7166667\n```\n:::\n:::\n\n\n\nWhen we run this we find out that the result Is 0.71. That's pretty close to zero but the prediction seemed biased towards lower temperatures which, means they aren't as accurate as they could be.\n\nIf we were seeing consistent bias in our sample, we can use the `sample()` function to inject a randomization element into our R programming\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% \n  drop_na() %>% \n  group_by(species) %>%\n  summarise(min(bill_depth_mm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  species   `min(bill_depth_mm)`\n  <fct>                    <dbl>\n1 Adelie                    15.5\n2 Chinstrap                 16.4\n3 Gentoo                    13.1\n```\n:::\n:::\n",
    "supporting": [
      "3_data_in_R_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}