{
  "hash": "37610c91d5397832b8825c77819b5a0f",
  "result": {
    "markdown": "# Programming using RStudio\n\n## Fundamentals\n\n### Functions\n\n**Functions** are a body of reusable code used to perform specific tasks in R. Functions begin with function names like print or paste, and are usually followed by one or more arguments in parentheses. An **argument** is information that a function in R needs in order to run. I.e. `print()` will return whatever we include in the values in parentheses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"Coding in R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Coding in R\"\n```\n:::\n:::\n\n\nIf you want to find out more about the print function or any function, all you have to do is type a question mark, the function name, and a set of parentheses. This returns a page in the Help window, which helps you learn more about the functions you're working with. Keep in mind that functions are case-sensitive, so typing Print with a Capital P brings back an error message.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?print()\n```\n:::\n\n\nFunctions are great, but it can be pretty time-consuming to type out lots of values. To save time, we can use variables to represent the values. This lets us call out the values any time we need to with just the variable. A **variable** is a representation of a value in R that can be stored for use later during programming. Variables can also be called objects. A variable name should start with a letter and can also contain numbers and underscores. \n\n\n### Comments\n\nComments are helpful when you want to describe or explain what's going on in your code. Use them as much as possible so that you and everyone can understand the reasoning behind it. Comments should be used to make an R script more readable. A comment shouldn't be treated as code, so we'll put a # in front of it. Then we'll add our comment. Here's an example of a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Here is an example of a variable\nfirst_variable <- \"My variable\"\nfirst_variable\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"My variable\"\n```\n:::\n:::\n\n\nAbove the `<-`  is the **assignment operator**. It assigns the value to the variable.\n\n\n### Data structures\n\nA **data structure** is a format for organizing and storing data. The most common data structures in the R\nprogramming language include:\n\n- Vectors\n- Data frames\n- Matrices\n- Arrays\n\n\n### Vectors\n\nA **vector** is a group of data elements of the same type stored in a sequence in R. \n\nThere are two types of vectors: atomic vectors and lists. \n\n#### Atomic vectors\n\nThere are six primary types of atomic vectors: \n\n- Logical: True/False\n- Integer: Positive or negative whole values\n- Double: Decimal values\n- Character: String/character values\n- Complex\n- Raw\n\nTogether, integer and double vectors are known as **numeric vectors** because they both contain numbers. \n\n\n#### Creating vectors\n\nYou can make a vector using the combined function. In R this function is just the letter c followed by the values you want in your vector inside parentheses, i.e. `c()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_1 <- c(13,48.5, 71, 101.5,2)\nvec_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  13.0  48.5  71.0 101.5   2.0\n```\n:::\n:::\n\n\n\n#### Determining the properties of vectors \n\nEvery vector you create will have two key properties: type and length.  \n\nYou can determine what type of vector you are working with by using the typeof() function. Place the code for the vector inside the parentheses of the function. When you run the function, R will tell you the type. For example: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(vec_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\nYou can determine the length of an existing vector<e2><80><93>meaning the number of elements it contains<e2><80><93>by using the length() function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vec_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nYou can also check if a vector is a specific type by using an is function: is.logical(), is.double(), is.integer(), is.character(). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.character(vec_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\n#### Naming vectors\n\nAll types of vectors can be named. Names are useful for writing readable code and describing objects in R. You can name the elements of a vector with the names() function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a vector\nx <- c(1, 3, 5)\n\n#assign names to each element of a vector\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n#view vector\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c \n1 3 5 \n```\n:::\n:::\n\n\n\n### Lists\n\nLists are different from atomic vectors because their elements can be of any type<e2><80><94>like dates, data frames, vectors, matrices, and more. Lists can even contain other lists. \n\nYou can create a list with the list() function. Similar to the c() function, the list() function is just list followed by the values you want in your list inside parentheses.\n\n\n#### Determining the structure of lists \n\nIf you want to find out what types of elements a list contains, you can use the str() function. To do so, place the code for the list inside the parentheses of the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(\"a\", 1L, 1.5, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ : chr \"a\"\n $ : int 1\n $ : num 1.5\n $ : logi TRUE\n```\n:::\n:::\n\n\nLet<e2><80><99>s use the str() function to discover the structure of our second example.  First, let<e2><80><99>s assign the list to the variable z to make it easier to input in the str() function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- list(list(list(1 , 3, 5)))\nstr(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ :List of 1\n  ..$ :List of 3\n  .. ..$ : num 1\n  .. ..$ : num 3\n  .. ..$ : num 5\n```\n:::\n:::\n\n\nThe indentation of the $ symbols reflect the nested structure of this list. Here, there are three levels (so there is a list within a list within a list).  \n\n\n#### Naming lists\n\nLists, like vectors, can be named. You can name the elements of a list when you first create it with the list() function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist('Chicago' = 1, 'New York' = 2, 'Los Angeles' = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Chicago\n[1] 1\n\n$`New York`\n[1] 2\n\n$`Los Angeles`\n[1] 3\n```\n:::\n:::\n\n\n\n### Matrices\n\nA matrix is a two-dimensional collection of data elements. This means it has both rows and columns. By contrast, a vector is a one-dimensional sequence of data elements. But like vectors, matrices can only contain a single data type. For example, you can<e2><80><99>t have both logicals and numerics in a matrix. \n\nTo create a matrix in R, you can use the matrix() function. The matrix() function has two main arguments that you enter in the parentheses. First, add a vector. The vector contains the values you want to place in the matrix. Next, add at least one matrix dimension. You can choose to specify the number of rows or the number of columns by using the code nrow = or ncol =. \n\nFor example, imagine you want to create a 2x3 (two rows by three columns) matrix containing the values 3-8. First, enter a vector containing that series of numbers: c(3:8). Then, enter a comma. Finally, enter nrow = 2 to specify the number of rows. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(c(3:8), nrow = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    3    5    7\n[2,]    4    6    8\n```\n:::\n:::\n\n\nYou can also choose to specify the number of columns (ncol = ) instead of the number of rows (nrow = ). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(c(3:8), ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    3    6\n[2,]    4    7\n[3,]    5    8\n```\n:::\n:::\n\n\n\n### Data frames\n\nData frames are the most common way of storing and analyzing data in R, so it<e2><80><99>s important to understand what they are and how to create them. A data frame is a collection of columns<e2><80><93>similar to a spreadsheet or SQL table. Each column has a name at the top that represents a variable, and includes one observation per row. Data frames help summarize data and organize it into a format that is easy to read and use. \n\nThere are a few key things to keep in mind when you are working with data frames: \n\n- Columns should be named. \n- Data frames can include many different types of data, like numeric, logical, or character.\n- Elements in the same column should be of the same type.\n\n\n#### Creating dfs\n\nIf you need to manually create a data frame in R, you can use the data.frame() function. The data.frame() function takes vectors as input. In the parentheses, enter the name of the column, followed by an equals sign, and then the vector you want to input for that column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = c(1, 2, 3) , y = c(1.5, 5.5, 7.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x   y\n1 1 1.5\n2 2 5.5\n3 3 7.5\n```\n:::\n:::\n\n\n\n\n## Files\n\nLet<e2><80><99>s go over how to create, copy, and delete files in R. For more information on working with files in R.\n\nUse the `dir.create` function to create a new folder, or directory, to hold your files. Place the name of the folder in the parentheses of the function. \n\n```\ndir.create (\"destination_folder\")\n```\n\nUse the file.create() function to create a blank file. Place the name and the type of the file in the parentheses of the function. Your file types will usually be something like .txt, .docx, or .csv.  \n\n```\nfile.create (\"new_text_file.txt\")\n```\n\nCopying a file can be done using the file.copy() function. In the parentheses, add the name of the file to be copied. Then, type a comma, and add the name of the destination folder that you want to copy the file to. \n\n```file.copy (\"new_text_file.txt\" , \"destination_folder\")```\n\nYou can delete R files using the unlink() function. Enter the file<e2><80><99>s name in the parentheses of the function.\n\n```unlink (\"some_.file.csv\")```\n\n\n\n\n## Pipes\n\nA **pipe** is a tool in R for expressing a sequence of multiple operations. A pipe is represented with `%>%`.It's used to apply the output of one function into another function.\n\n\n\n## Packages\n\n**Packages** are units of reproducible R code, and they make it easier to keep track of code. They're created by members of the R community to keep track of the R functions that they write and reuse\n\nPackages in R include reusable R functions and documentation about the functions, including how to use them. They also contain sample datasets and tests for checking your code to make sure it does what you want it to do.\n\nBy default, R includes a set of packages called **Base R** that are available to use in RStudio when you start your first programming session. \n\nTo check already installed packages we can type \n\n::: {.cell}\n\n```{.r .cell-code}\npackages <- as.data.frame(installed.packages())\nhead(packages)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                Package\nAlgDesign     AlgDesign\nAsioHeaders AsioHeaders\nDBI                 DBI\nFormula         Formula\nKernSmooth   KernSmooth\nMASS               MASS\n                                                                   LibPath\nAlgDesign   /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nAsioHeaders /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nDBI         /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nFormula     /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nKernSmooth  /Library/Frameworks/R.framework/Versions/4.2/Resources/library\nMASS        /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n             Version    Priority\nAlgDesign      1.2.1        <NA>\nAsioHeaders 1.22.1-1        <NA>\nDBI            1.1.3        <NA>\nFormula        1.2-4        <NA>\nKernSmooth   2.23-20 recommended\nMASS          7.3-57 recommended\n                                                    Depends Imports LinkingTo\nAlgDesign                                              <NA>    <NA>      <NA>\nAsioHeaders                                            <NA>    <NA>      <NA>\nDBI                                   methods, R (>= 3.0.0)    <NA>      <NA>\nFormula                                 R (>= 2.0.0), stats    <NA>      <NA>\nKernSmooth                              R (>= 2.5.0), stats    <NA>      <NA>\nMASS        R (>= 3.3.0), grDevices, graphics, stats, utils methods      <NA>\n                                                                                                                                                 Suggests\nAlgDesign                                                                                                                                            <NA>\nAsioHeaders                                                                                                                                          <NA>\nDBI         blob, covr, DBItest, dbplyr, downlit, dplyr, glue, hms,\\nknitr, magrittr, RMariaDB, rmarkdown, rprojroot, RSQLite (>=\\n1.1-2), testthat, xml2\nFormula                                                                                                                                              <NA>\nKernSmooth                                                                                                                                  MASS, carData\nMASS                                                                                                                        lattice, nlme, nnet, survival\n            Enhances       License License_is_FOSS License_restricts_use\nAlgDesign       <NA>    GPL (>= 2)            <NA>                  <NA>\nAsioHeaders     <NA>       BSL-1.0            <NA>                  <NA>\nDBI             <NA> LGPL (>= 2.1)            <NA>                  <NA>\nFormula         <NA> GPL-2 | GPL-3            <NA>                  <NA>\nKernSmooth      <NA>     Unlimited            <NA>                  <NA>\nMASS            <NA> GPL-2 | GPL-3            <NA>                  <NA>\n            OS_type MD5sum NeedsCompilation Built\nAlgDesign      <NA>   <NA>              yes 4.2.0\nAsioHeaders    <NA>   <NA>               no 4.2.0\nDBI            <NA>   <NA>               no 4.2.0\nFormula        <NA>   <NA>               no 4.2.0\nKernSmooth     <NA>   <NA>              yes 4.2.1\nMASS           <NA>   <NA>              yes 4.2.1\n```\n:::\n:::\n\nThe package column gives the name of the package like cluster or graphics. The priority column tells us what's needed to use functions from the package. If you come across the word \"base\" in the priority column, then the package is already installed and loaded.\n\nPackages can be found in repositories, which are collections of useful packages that are ready to install. You can find repositories on Bioconductor, R-Forge, rOpenSci, or GitHub, but the most commonly used repository is the Comprehensive R Archive Network or CRAN. CRAN stores code and documentation so that you can install packages into your own RStudio space. \n\nConflicts happen when packages have functions with the same names as other functions. Basically, the last package loaded is the one whose functions will be used\n\n\n## Dates and times in R\n\nIn this reading, you will learn how to work with dates and times in R using the lubridate package. Lubridate is part of tidyverse. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load required libs\nlibrary(tidyverse)\nlibrary(lubridate)\n```\n:::\n\n\nIn R, there are three types of data that refer to an instant in time:\n\n- A date (\"2016-08-16\")\n- A time within a day (\"20:11:59 UTC\")\n- And a date-time. This is a date plus a time (\"2018-03-31 18:15:48 UTC\")\n\nFor example, to get the current date you can run the today() function. The date appears as year, month, and day. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-11-11\"\n```\n:::\n:::\n\n\nTo get the current date-time you can run the now() function. Note that the time appears to the nearest second. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-11-11 14:44:07 CET\"\n```\n:::\n:::\n\n\nWhen working with R, there are three ways you are likely to create date-time formats: \n\n- From a string\n- From an individual date\n- From an existing date/time object\n\nR creates dates in the standard yyyy-mm-dd format by default. \n\n### Converting from strings \n\nDate/time data often comes as strings. You can convert strings into dates and date-times using the tools provided by lubridate. These tools automatically work out the date/time format. First, identify the order in which the year, month, and day appear in your dates. Then, arrange the letters y, m, and d in the same order. That gives you the name of the lubridate function that will parse your date.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"2021-01-20\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-01-20\"\n```\n:::\n:::\n\n\nIt works the same way for any order. For example, month, day, and year. R still returns the date in yyyy-mm-dd format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy(\"January 20th, 2021\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-01-20\"\n```\n:::\n:::\n\n\nThese functions also take unquoted numbers and convert them into the yyyy-mm-dd format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(20210120)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-01-20\"\n```\n:::\n:::\n\n\n### Creating date-time components\n\nThe ymd() function and its variations create dates. To create a date-time from a date, add an underscore and one or more of the letters h, m, and s (hours, minutes, seconds) to the name of the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nymd_hms(\"2021-01-20 20:11:59\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-01-20 20:11:59 UTC\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy_hm(\"01/20/2021 08:01\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-01-20 08:01:00 UTC\"\n```\n:::\n:::\n\n\n### Optional: Switching between existing date-time objects \n\nFinally, you might want to switch between a date-time and a date. \n\nYou can use the function as_date() to convert a date-time to a date. For example, put the current date-time<e2><80><94>now()<e2><80><94>in the parentheses of the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_date(now())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-11-11\"\n```\n:::\n:::\n\n\n\n\n## Operators and calculations\n\n**Operators** are defined as a symbol that names the type of operation or calculation to be performed in a formula. Arithmetic operators are used to complete math calculations.\n\n**Arithmetic operators** let you perform basic math operations like addition, subtraction, multiplication, and division.\n\n<img width=500 src=\"../images/operators.png\">\n\nIn the example above, we assume that `x <- 2` and `y <-5`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquarter_1_sales <- 35657.98\nquarter_2_sales <- 43810.55\nmidyear_sales <- quarter_1_sales + quarter_2_sales\nmidyear_sales\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 79468.53\n```\n:::\n:::\n\n\n**Logical operators** return a logical data type such as TRUE or FALSE. \nThere are three primary types of logical operators:\n\n<img width=500 src=\"../images/log_operators.png\">\n\nThe main difference between **element-wise logical operators** (&, |) and **logical operators** (&&, ||) is the way they apply to operations with vectors. The operations with double signs, AND (&&) and logical OR (||), only examine the first element of each vector. The operations with single signs, AND (&) and OR (|), examine all the elements of each vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, 5, 7)\ny <- c(2, 4, 6)\n\nx < 5 & y < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx < 5 && y < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n\n**Relational operators**, also known as comparators, allow you to compare values. Relational operators identify how one R object relates to another<e2><80><94>like whether an object is less than, equal to, or greater than another object. The output for relational operators is either TRUE or FALSE (which is a logical data type, or boolean).\n\n<img width=500 src=\"../images/rel_operators.png\">\n\n\n**Assignment operators** let you assign values to variables. \n\nIn many scripting programming languages you can just use the equal sign (=) to assign a variable. For R, the best practice is to use the arrow assignment (<-). Technically, the single arrow assignment can be used in the left or right direction. But the rightward assignment is not generally used in R code. \n\n\n\n## Conditional statements\n\nA **conditional statement** is a declaration that if a certain condition holds, then a certain event must take place.\n\n### if statement\nThe if statement sets a condition, and if the condition evaluates to TRUE, the R code associated with the if statement is executed.\n\nIn R, you place the code for the condition inside the parentheses of the if statement. The code that has to be executed if the condition is TRUE follows in curly braces (expr). Note that in this case, the second curly brace is placed on its own line of code and identifies the end of the code that you want to execute. \n```\nif (condition) {\n expr\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 4\n\nif (x > 0) {\n    print(\"x is a positive number\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is a positive number\"\n```\n:::\n:::\n\n\nif you change x to a negative number, like -4, then the condition will be FALSE (-4 > 0). If you run the code, R will not execute the print statement. Instead, a blank line will appear as the result.\n\n\n### else statement\n\nThe else statement is used in combination with an if statement. This is how the code is structured in R: \n\n```\nif (condition) {\n  expr1\n} else {\n expr2\n}\n```\n\nLet's try the following: \n\n- If x is greater than 0, R will print <e2><80><9c>x is a positive number<e2><80><9d>.\n- If x is less than or equal to 0, R will print <e2><80><9c>x is either a negative number or zero<e2><80><9d>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -7\n\nif (x > 0) {\n    print(\"x is a positive number\")\n} else {\n    print(\"x is either a negative number or zero\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is either a negative number or zero\"\n```\n:::\n:::\n\n\n### else if statement\n\nIn some cases, you might want to customize your conditional statement even further by adding the else if statement. The else if statement comes in between the if statement and the else statement. This is the code structure: \n\n```\nif (condition1) {\n expr1\n} else if (condition2) {\n expr2\n} else {\n expr3\n}\n```\n\nIf the if condition (condition1) is met, then R executes the code in the first expression (expr1). If the if condition is not met, and the else if condition (condition2) is met, then R executes the code in the second expression (expr2). If neither of the two conditions are met, R executes the code in the third expression (expr3). \n\nIn our previous example, using only the if and else statements, R can only print <e2><80><9c>x is either a negative number or zero<e2><80><9d> if x equals 0 or x is less than zero. Imagine you want R to print the string <e2><80><9c>x is zero<e2><80><9d> if x equals 0. You need to add another condition using the else if statement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -1\n\nif (x < 0) {\n    print(\"x is a negative number\")\n} else if (x == 0) {\n    print(\"x is zero\")\n} else {\n    print(\"x is a positive number\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is a negative number\"\n```\n:::\n:::\n\n\n## Keeping Your Code Readable\n\n- File names should be meaningful\n- Avoid using special characters in file names<e2><80><94>stick with numbers,letters, dashes, and underscores.\n- Variable and function names should be lowercase. Use an underscore _ to separate words within a name. Try to create names that are clear, concise, and meaningful.\n- Most operators (== , + , - , <- ,etc.) should be surrounded by spaces.\n- Always put a space after a comma (never before).\n- Do not place spaces around code in parentheses or square brackets (unless there<e2><80><99>s a comma, in which case see above).\n- An opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line (unless it<e2><80><99>s followed by an else statement). Always indent the code inside curly braces.\n- When indenting your code, use two spaces. Do not use tabs or mix tabs and spaces.\n- Try to limit your code to 80 characters per line. This fits nicely on a printed page with a reasonably sized font.\n- Use <- , not = , for assignment.\n- Entire commented lines should begin with the comment symbol and a single space: #.\n\n\n\n## Viewing data\n\nMany of the `tidyverse` packages contain sample datasets that you can use to practice your `R` skills. The `diamonds` dataset in the `ggplot2` package is a great example for previewing `R` functions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n```\n:::\n:::\n\nIn addition to `head()` there are a number of other useful functions you can use to summarize or preview the data. For example, the `str()` and `glimpse()` functions will both return summaries of each column in your data arranged horizontally. You can try out these two functions by running the code chunks below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 53,940\nColumns: 10\n$ carat   <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.~\n$ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver~\n$ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,~\n$ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, ~\n$ depth   <dbl> 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64~\n$ table   <dbl> 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58~\n$ price   <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34~\n$ x       <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.~\n$ y       <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.~\n$ z       <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.~\n```\n:::\n:::\n\nAnother simple function that you may use regularly is the `colnames()` function. It returns a list of column names from your dataset. You can check out this function by running the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"carat\"   \"cut\"     \"color\"   \"clarity\" \"depth\"   \"table\"   \"price\"  \n [8] \"x\"       \"y\"       \"z\"      \n```\n:::\n:::\n\n\n\n## Cleaning data\n\nOne of the most frequent tasks you will have to perform as an analyst is to clean and organize your data. `R` makes this easy! There are many functions you can use to help you perform important tasks easily and quickly. \n\nFor example, you might need to rename the columns, or variables, in your data. There is a function for that: `rename().` You can check out how it works in the chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(diamonds, carat_new = carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 x 10\n   carat_new cut       color clarity depth table price     x     y     z\n       <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1      0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2      0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3      0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4      0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5      0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6      0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7      0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8      0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9      0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10      0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ... with 53,930 more rows\n```\n:::\n:::\n\nYou can rename more than one variable in the same `rename()` code. The code below demonstrates how:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(diamonds, carat_new = carat, cut_new = cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 x 10\n   carat_new cut_new   color clarity depth table price     x     y     z\n       <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1      0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2      0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3      0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4      0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5      0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6      0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7      0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8      0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9      0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10      0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ... with 53,930 more rows\n```\n:::\n:::\n\n\nAnother handy function for summarizing your data is `summarize().` You can use it to generate a wide range of summary statistics for your data. For example, if you wanted to know what the mean for `carat` was in this dataset, you could run the code in the chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(diamonds, mean_carat = mean(carat))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n  mean_carat\n       <dbl>\n1      0.798\n```\n:::\n:::\n\n## Visualizing data\n\nWith `R,` you can create data visualizations that are simple and easy to understand or complicated and beautiful just by changing a bit of code. `R` empowers you to present the same data in so many different ways, which can help you create new insights or highlight important data findings.  One of the most commonly used visualization packages is the `ggplot2` package, which is loaded automatically when you install and load `tidyverse.`\n\nTo build a visualization with `ggplot2` you layer plot elements together with a `+` symbol. You will learn a lot more about using `ggplot2` later in the course, but here is a preview of how easy and flexible it is to make visuals using code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = diamonds, aes(x = carat, y = price)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](2_rstudio_files/figure-html/unnamed-chunk-38-1.png){width=336}\n:::\n:::\n\n\nThe code above takes the `diamonds` data, plots the carat column on the X-axis, the price column on the Y-axis, and represents the data as a scatter plot using the `geom_point()` command. \n\n`ggplot2` makes it easy to modify or improve your visuals. For example, if you wanted to change the color of each point so that it represented another variable, such as the cut of the diamond, you can change the code like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](2_rstudio_files/figure-html/unnamed-chunk-39-1.png){width=336}\n:::\n:::\n\n\nSometimes when you are trying to represent many different aspects of your data in a visual, it can help to separate out some of the components. For example, you could create a different plot for each type of cut. `ggplot2` makes it easy to do this with the `facet_wrap()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point() +\n    facet_wrap(~cut)\n```\n\n::: {.cell-output-display}\n![](2_rstudio_files/figure-html/unnamed-chunk-40-1.png){width=336}\n:::\n:::\n\n\n\n## The tidyverse\n\nTidyverse is actually a collection of packages in R with a common design philosophy for data manipulation, exploration, and visualization. \n\nThe packages are ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr, and forcats.\n\n- **readr** is used for importing data\n- **Ggplot2** is used for data visualization, specifically plots. With ggplot2, you can create a variety of data viz by applying different visual properties to the data variables.\n- **Tidyr** is a package used for data cleaning to make tidy data\n- **Dplyr** offers a consistent set of functions that help you complete some common data manipulation tasks. For example, the select function picks variables based on their names, and the filter function finds cases where certain conditions are true\n- **Tibble** works with data frames. \n- **Purrr** works with functions and vectors helping make your code easier to write and more expressive. \n- **Stringr** includes functions that make it easier to work with strings.\n- **Forcats** provides tools that solve common problems with factors. As a quick reminder, factors store categorical data in R where the data values are limited and usually based on a finite group like country or year.\n\n\n### Checking for updates\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tidyverse_update()\n```\n:::\n\n\n\n\n### Read tidyverse vignettes \n\nA vignette is documentation that acts as a guide to an R package. A vignette shares details about the problem that the package is designed to solve and how the included functions can help you solve it. The browseVignettes function allows you to read through vignettes of a loaded package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#browseVignettes(\"ggplot2\")\n```\n:::\n\n\n\n\n### Working with pipes\n\n**Nested** describes code that performs a particular function and is contained within code that performs a broader function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load an already installed dataset\ndata(\"ToothGrowth\")\nhead(ToothGrowth)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   len supp dose\n1  4.2   VC  0.5\n2 11.5   VC  0.5\n3  7.3   VC  0.5\n4  5.8   VC  0.5\n5  6.4   VC  0.5\n6 10.0   VC  0.5\n```\n:::\n:::\n\nNow, let's say we need to filter and sort this data to organize it for analysis. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#apply the filter fct from the dplyr package\n#to only include rows were the dose of vitamin is 0.5\nfiltered_tg <- filter(ToothGrowth, dose == 0.5)\n\n#check dimensions\ndim(ToothGrowth)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 60  3\n```\n:::\n\n```{.r .cell-code}\ndim(filtered_tg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20  3\n```\n:::\n:::\n\n\nNext, lets sort the data with the `arrange()` fct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#first we have the df, then the column we want to sort by\narrange(filtered_tg, len)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n```\n:::\n:::\n\n\nLet's now use a nested function to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(filter(ToothGrowth, dose == 0.5), len)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n```\n:::\n:::\n\nNotice that the filter function from our previous code is the nested function. With nested functions, we read from the inside out. The code filters the data first. Then it arranges or sorts it.\n\nNow, let's use a pipe:\n\nThe shortcut to enter a pipe is `cmd+shift+m`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_toothgrowh <- ToothGrowth |> \n    filter(dose==0.5) |> \n    arrange(len)\n\nfiltered_toothgrowh\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    len supp dose\n1   4.2   VC  0.5\n2   5.2   VC  0.5\n3   5.8   VC  0.5\n4   6.4   VC  0.5\n5   7.0   VC  0.5\n6   7.3   VC  0.5\n7   8.2   OJ  0.5\n8   9.4   OJ  0.5\n9   9.7   OJ  0.5\n10  9.7   OJ  0.5\n11 10.0   VC  0.5\n12 10.0   OJ  0.5\n13 11.2   VC  0.5\n14 11.2   VC  0.5\n15 11.5   VC  0.5\n16 14.5   OJ  0.5\n17 15.2   OJ  0.5\n18 16.5   OJ  0.5\n19 17.6   OJ  0.5\n20 21.5   OJ  0.5\n```\n:::\n:::\n\n\nBuilding on our example, let's say we also wanted to compute the average tooth length or len for each of the two supplements used in the study: orange juice or OJ and ascorbic acid or VC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_toothgrowh <- ToothGrowth |> \n    filter(dose==0.5) |> \n    #group by tooth supplements\n    group_by(supp) |> \n    #summarize data by group\n    summarise(mean_len = mean(len, na.rm = T), .group = \"drop\")\n\nfiltered_toothgrowh\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  supp  mean_len .group\n  <fct>    <dbl> <chr> \n1 OJ       13.2  drop  \n2 VC        7.98 drop  \n```\n:::\n:::\n",
    "supporting": [
      "2_rstudio_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}